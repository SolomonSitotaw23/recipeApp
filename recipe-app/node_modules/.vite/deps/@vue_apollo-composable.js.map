{
  "version": 3,
  "sources": ["../../throttle-debounce/throttle.js", "../../throttle-debounce/debounce.js", "../../@vue/apollo-composable/src/useQuery.ts", "../../@vue/apollo-composable/src/useApolloClient.ts", "../../@vue/apollo-composable/src/util/paramToRef.ts", "../../@vue/apollo-composable/src/util/paramToReactive.ts", "../../@vue/apollo-composable/src/util/useEventHook.ts", "../../@vue/apollo-composable/src/util/loadingTracking.ts", "../../@vue/apollo-composable/src/util/toApolloError.ts", "../../@vue/apollo-composable/src/util/env.ts", "../../@vue/apollo-composable/src/useLazyQuery.ts", "../../@vue/apollo-composable/src/useMutation.ts", "../../@vue/apollo-composable/src/useSubscription.ts", "../../@vue/apollo-composable/src/useResult.ts", "../../@vue/apollo-composable/src/useLoading.ts"],
  "sourcesContent": ["/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset).\n * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function}  A new, throttled, function.\n */\nexport default function (delay, noTrailing, callback, debounceMode) {\n\t/*\n\t * After wrapper has stopped being called, this timeout ensures that\n\t * `callback` is executed at the proper times in `throttle` and `end`\n\t * debounce modes.\n\t */\n\tlet timeoutID;\n\tlet cancelled = false;\n\n\t// Keep track of the last time `callback` was executed.\n\tlet lastExec = 0;\n\n\t// Function to clear existing timeout\n\tfunction clearExistingTimeout() {\n\t\tif (timeoutID) {\n\t\t\tclearTimeout(timeoutID);\n\t\t}\n\t}\n\n\t// Function to cancel next exec\n\tfunction cancel() {\n\t\tclearExistingTimeout();\n\t\tcancelled = true;\n\t}\n\n\t// `noTrailing` defaults to falsy.\n\tif (typeof noTrailing !== 'boolean') {\n\t\tdebounceMode = callback;\n\t\tcallback = noTrailing;\n\t\tnoTrailing = undefined;\n\t}\n\n\t/*\n\t * The `wrapper` function encapsulates all of the throttling / debouncing\n\t * functionality and when executed will limit the rate at which `callback`\n\t * is executed.\n\t */\n\tfunction wrapper(...arguments_) {\n\t\tlet self = this;\n\t\tlet elapsed = Date.now() - lastExec;\n\n\t\tif (cancelled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Execute `callback` and update the `lastExec` timestamp.\n\t\tfunction exec() {\n\t\t\tlastExec = Date.now();\n\t\t\tcallback.apply(self, arguments_);\n\t\t}\n\n\t\t/*\n\t\t * If `debounceMode` is true (at begin) this is used to clear the flag\n\t\t * to allow future `callback` executions.\n\t\t */\n\t\tfunction clear() {\n\t\t\ttimeoutID = undefined;\n\t\t}\n\n\t\tif (debounceMode && !timeoutID) {\n\t\t\t/*\n\t\t\t * Since `wrapper` is being called for the first time and\n\t\t\t * `debounceMode` is true (at begin), execute `callback`.\n\t\t\t */\n\t\t\texec();\n\t\t}\n\n\t\tclearExistingTimeout();\n\n\t\tif (debounceMode === undefined && elapsed > delay) {\n\t\t\t/*\n\t\t\t * In throttle mode, if `delay` time has been exceeded, execute\n\t\t\t * `callback`.\n\t\t\t */\n\t\t\texec();\n\t\t} else if (noTrailing !== true) {\n\t\t\t/*\n\t\t\t * In trailing throttle mode, since `delay` time has not been\n\t\t\t * exceeded, schedule `callback` to execute `delay` ms after most\n\t\t\t * recent execution.\n\t\t\t *\n\t\t\t * If `debounceMode` is true (at begin), schedule `clear` to execute\n\t\t\t * after `delay` ms.\n\t\t\t *\n\t\t\t * If `debounceMode` is false (at end), schedule `callback` to\n\t\t\t * execute after `delay` ms.\n\t\t\t */\n\t\t\ttimeoutID = setTimeout(\n\t\t\t\tdebounceMode ? clear : exec,\n\t\t\t\tdebounceMode === undefined ? delay - elapsed : delay\n\t\t\t);\n\t\t}\n\t}\n\n\twrapper.cancel = cancel;\n\n\t// Return the wrapper function.\n\treturn wrapper;\n}\n", "/* eslint-disable no-undefined */\n\nimport throttle from './throttle';\n\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                  to `callback` when the debounced-function is executed.\n *\n * @returns {Function} A new, debounced function.\n */\nexport default function (delay, atBegin, callback) {\n\treturn callback === undefined\n\t\t? throttle(delay, atBegin, false)\n\t\t: throttle(delay, callback, atBegin !== false);\n}\n", "import {\n  ref,\n  Ref,\n  unref,\n  computed,\n  watch,\n  onServerPrefetch,\n  getCurrentInstance,\n  onBeforeUnmount,\n  nextTick,\n} from 'vue-demi'\nimport { DocumentNode } from 'graphql'\nimport {\n  OperationVariables,\n  WatchQueryOptions,\n  ObservableQuery,\n  ApolloQueryResult,\n  SubscribeToMoreOptions,\n  FetchMoreQueryOptions,\n  FetchMoreOptions,\n  ObservableSubscription,\n  TypedDocumentNode,\n  ApolloError,\n} from '@apollo/client/core'\nimport { throttle, debounce } from 'throttle-debounce'\nimport { useApolloClient } from './useApolloClient'\nimport { ReactiveFunction } from './util/ReactiveFunction'\nimport { paramToRef } from './util/paramToRef'\nimport { paramToReactive } from './util/paramToReactive'\nimport { useEventHook } from './util/useEventHook'\nimport { trackQuery } from './util/loadingTracking'\nimport { resultErrorsToApolloError, toApolloError } from './util/toApolloError'\nimport { isServer } from './util/env'\n\nimport type { CurrentInstance } from './util/types'\n\nexport interface UseQueryOptions<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TResult = any,\n  TVariables = OperationVariables\n> extends Omit<WatchQueryOptions<TVariables>, 'query' | 'variables'> {\n  clientId?: string\n  enabled?: boolean\n  throttle?: number\n  debounce?: number\n  prefetch?: boolean\n}\n\ninterface SubscribeToMoreItem {\n  options: any\n  unsubscribeFns: (() => void)[]\n}\n\n// Parameters\nexport type DocumentParameter<TResult, TVariables = undefined> = DocumentNode | Ref<DocumentNode> | ReactiveFunction<DocumentNode> | TypedDocumentNode<TResult, TVariables> | Ref<TypedDocumentNode<TResult, TVariables>> | ReactiveFunction<TypedDocumentNode<TResult, TVariables>>\nexport type VariablesParameter<TVariables> = TVariables | Ref<TVariables> | ReactiveFunction<TVariables>\nexport type OptionsParameter<TResult, TVariables> = UseQueryOptions<TResult, TVariables> | Ref<UseQueryOptions<TResult, TVariables>> | ReactiveFunction<UseQueryOptions<TResult, TVariables>>\n\n// Return\nexport interface UseQueryReturn<TResult, TVariables> {\n  result: Ref<TResult | undefined>\n  loading: Ref<boolean>\n  networkStatus: Ref<number | undefined>\n  error: Ref<ApolloError | null>\n  start: () => void\n  stop: () => void\n  restart: () => void\n  forceDisabled: Ref<boolean>\n  document: Ref<DocumentNode>\n  variables: Ref<TVariables | undefined>\n  options: UseQueryOptions<TResult, TVariables> | Ref<UseQueryOptions<TResult, TVariables>>\n  query: Ref<ObservableQuery<TResult, TVariables> | null | undefined>\n  refetch: (variables?: TVariables) => Promise<ApolloQueryResult<TResult>> | undefined\n  fetchMore: (options: FetchMoreQueryOptions<TVariables, TResult> & FetchMoreOptions<TResult, TVariables>) => Promise<ApolloQueryResult<TResult>> | undefined\n  subscribeToMore: <TSubscriptionVariables = OperationVariables, TSubscriptionData = TResult>(options: SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData> | Ref<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>> | ReactiveFunction<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>>) => void\n  onResult: (fn: (param: ApolloQueryResult<TResult>) => void) => {\n    off: () => void\n  }\n  onError: (fn: (param: ApolloError) => void) => {\n    off: () => void\n  }\n}\n\n/**\n * Use a query that does not require variables or options.\n * */\nexport function useQuery<TResult = any> (\n  document: DocumentParameter<TResult, undefined>\n): UseQueryReturn<TResult, undefined>\n\n/**\n * Use a query that has optional variables but not options\n */\nexport function useQuery<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>\n): UseQueryReturn<TResult, TVariables>\n\n/**\n * Use a query that has required variables but not options\n */\nexport function useQuery<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>\n): UseQueryReturn<TResult, TVariables>\n\n/**\n * Use a query that requires options but not variables.\n */\nexport function useQuery<TResult = any> (\n  document: DocumentParameter<TResult, undefined>,\n  variables: undefined | null,\n  options: OptionsParameter<TResult, null>,\n): UseQueryReturn<TResult, null>\n\n/**\n * Use a query that requires variables and options.\n */\nexport function useQuery<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>,\n  options: OptionsParameter<TResult, TVariables>,\n): UseQueryReturn<TResult, TVariables>\n\nexport function useQuery<\n  TResult,\n  TVariables extends OperationVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables?: VariablesParameter<TVariables>,\n  options?: OptionsParameter<TResult, TVariables>,\n): UseQueryReturn<TResult, TVariables> {\n  return useQueryImpl<TResult, TVariables>(document, variables, options)\n}\n\nexport function useQueryImpl<\n  TResult,\n  TVariables extends OperationVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables?: VariablesParameter<TVariables>,\n  options: OptionsParameter<TResult, TVariables> = {},\n  lazy = false,\n): UseQueryReturn<TResult, TVariables> {\n  // Is on server?\n  const vm = getCurrentInstance() as CurrentInstance | null\n\n  const currentOptions = ref<UseQueryOptions<TResult, TVariables>>()\n\n  const documentRef = paramToRef(document)\n  const variablesRef = paramToRef(variables)\n  const optionsRef = paramToReactive(options)\n\n  // Result\n  /**\n   * Result from the query\n   */\n  const result = ref<TResult | undefined>()\n  const resultEvent = useEventHook<ApolloQueryResult<TResult>>()\n  const error = ref<ApolloError | null>(null)\n  const errorEvent = useEventHook<ApolloError>()\n\n  // Loading\n\n  /**\n   * Indicates if a network request is pending\n   */\n  const loading = ref(false)\n  vm && trackQuery(loading)\n  const networkStatus = ref<number>()\n\n  // SSR\n  let firstResolve: (() => void) | undefined\n  let firstReject: ((apolloError: ApolloError) => void) | undefined\n  vm && onServerPrefetch?.(() => {\n    if (!isEnabled.value || (isServer && currentOptions.value?.prefetch === false)) return\n\n    return new Promise<void>((resolve, reject) => {\n      firstResolve = () => {\n        resolve()\n        firstResolve = undefined\n        firstReject = undefined\n      }\n      firstReject = (apolloError: ApolloError) => {\n        reject(apolloError)\n        firstResolve = undefined\n        firstReject = undefined\n      }\n    }).then(stop).catch(stop)\n  })\n\n  // Apollo Client\n  const { resolveClient } = useApolloClient()\n\n  // Query\n\n  const query: Ref<ObservableQuery<TResult, TVariables> | null | undefined> = ref()\n  let observer: ObservableSubscription | undefined\n  let started = false\n\n  /**\n   * Starts watching the query\n   */\n  function start () {\n    if (\n      started || !isEnabled.value ||\n      (isServer && currentOptions.value?.prefetch === false)\n    ) {\n      if (firstResolve) firstResolve()\n      return\n    }\n\n    started = true\n    error.value = null\n    loading.value = true\n\n    const client = resolveClient(currentOptions.value?.clientId)\n\n    query.value = client.watchQuery<TResult, TVariables>({\n      query: currentDocument,\n      variables: currentVariables,\n      ...currentOptions.value,\n      ...(isServer && currentOptions.value?.fetchPolicy !== 'no-cache')\n        ? {\n          fetchPolicy: 'network-only',\n        }\n        : {},\n    })\n\n    startQuerySubscription()\n\n    if (!isServer && (currentOptions.value?.fetchPolicy !== 'no-cache' || currentOptions.value.notifyOnNetworkStatusChange)) {\n      const currentResult = query.value.getCurrentResult()\n\n      if (!currentResult.loading || currentResult.partial || currentOptions.value?.notifyOnNetworkStatusChange) {\n        onNextResult(currentResult)\n      }\n    }\n\n    if (!isServer) {\n      for (const item of subscribeToMoreItems) {\n        addSubscribeToMore(item)\n      }\n    }\n  }\n\n  function startQuerySubscription () {\n    if (observer && !observer.closed) return\n    if (!query.value) return\n\n    // Create subscription\n    observer = query.value.subscribe({\n      next: onNextResult,\n      error: onError,\n    })\n  }\n\n  function onNextResult (queryResult: ApolloQueryResult<TResult>) {\n    // Remove any previous error that may still be present from the last fetch (so result handlers\n    // don't receive old errors that may not even be applicable anymore).\n    error.value = null\n\n    processNextResult(queryResult)\n\n    // When `errorPolicy` is `all`, `onError` will not get called and\n    // ApolloQueryResult.errors may be set at the same time as we get a result\n    if (!queryResult.error && queryResult.errors?.length) {\n      processError(resultErrorsToApolloError(queryResult.errors))\n    }\n\n    if (firstResolve) {\n      firstResolve()\n      stop()\n    }\n  }\n\n  function processNextResult (queryResult: ApolloQueryResult<TResult>) {\n    result.value = queryResult.data && Object.keys(queryResult.data).length === 0 ? undefined : queryResult.data\n    loading.value = queryResult.loading\n    networkStatus.value = queryResult.networkStatus\n    resultEvent.trigger(queryResult)\n  }\n\n  function onError (queryError: unknown) {\n    // any error should already be an ApolloError, but we make sure\n    const apolloError = toApolloError(queryError)\n    const client = resolveClient(currentOptions.value?.clientId)\n    const errorPolicy = currentOptions.value?.errorPolicy || client.defaultOptions?.watchQuery?.errorPolicy\n\n    if (errorPolicy && errorPolicy !== 'none') {\n      processNextResult((query.value as ObservableQuery<TResult, TVariables>).getCurrentResult())\n    }\n    processError(apolloError)\n    if (firstReject) {\n      firstReject(apolloError)\n      stop()\n    }\n    // The observable closes the sub if an error occurs\n    resubscribeToQuery()\n  }\n\n  function processError (apolloError: ApolloError) {\n    error.value = apolloError\n    loading.value = false\n    networkStatus.value = 8\n    errorEvent.trigger(apolloError)\n  }\n\n  function resubscribeToQuery () {\n    if (!query.value) return\n    const lastError = query.value.getLastError()\n    const lastResult = query.value.getLastResult()\n    query.value.resetLastResults()\n    startQuerySubscription()\n    Object.assign(query.value, { lastError, lastResult })\n  }\n\n  let onStopHandlers: Array<() => void> = []\n\n  /**\n   * Stop watching the query\n   */\n  function stop () {\n    if (firstResolve) firstResolve()\n    if (!started) return\n    started = false\n    loading.value = false\n\n    onStopHandlers.forEach(handler => handler())\n    onStopHandlers = []\n\n    if (query.value) {\n      query.value.stopPolling()\n      query.value = null\n    }\n\n    if (observer) {\n      observer.unsubscribe()\n      observer = undefined\n    }\n  }\n\n  // Restart\n  let restarting = false\n  /**\n   * Queue a restart of the query (on next tick) if it is already active\n   */\n  function baseRestart () {\n    if (!started || restarting) return\n    restarting = true\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    nextTick(() => {\n      if (started) {\n        stop()\n        start()\n      }\n      restarting = false\n    })\n  }\n\n  let debouncedRestart: typeof baseRestart\n  let isRestartDebounceSetup = false\n  function updateRestartFn () {\n    // On server, will be called before currentOptions is initialized\n    // @TODO investigate\n    if (!currentOptions.value) {\n      debouncedRestart = baseRestart\n    } else {\n      if (currentOptions.value?.throttle) {\n        debouncedRestart = throttle(currentOptions.value.throttle, baseRestart)\n      } else if (currentOptions.value?.debounce) {\n        debouncedRestart = debounce(currentOptions.value.debounce, baseRestart)\n      } else {\n        debouncedRestart = baseRestart\n      }\n      isRestartDebounceSetup = true\n    }\n  }\n\n  function restart () {\n    if (!isRestartDebounceSetup) updateRestartFn()\n    debouncedRestart()\n  }\n\n  // Applying document\n  let currentDocument: DocumentNode\n  watch(documentRef, value => {\n    currentDocument = value\n    restart()\n  }, {\n    immediate: true,\n  })\n\n  // Applying variables\n  let currentVariables: TVariables | undefined\n  let currentVariablesSerialized: string\n  watch(variablesRef, (value, oldValue) => {\n    const serialized = JSON.stringify(value)\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value\n      restart()\n    }\n    currentVariablesSerialized = serialized\n  }, {\n    deep: true,\n    immediate: true,\n  })\n\n  // Applying options\n  watch(() => unref(optionsRef), value => {\n    if (currentOptions.value && (\n      currentOptions.value.throttle !== value.throttle ||\n      currentOptions.value.debounce !== value.debounce\n    )) {\n      updateRestartFn()\n    }\n    currentOptions.value = value\n    restart()\n  }, {\n    deep: true,\n    immediate: true,\n  })\n\n  // Refetch\n\n  function refetch (variables: TVariables | undefined = undefined) {\n    if (query.value) {\n      if (variables) {\n        currentVariables = variables\n      }\n      error.value = null\n      loading.value = true\n      return query.value.refetch(variables)\n        .then((refetchResult) => {\n          const currentResult = query.value?.getCurrentResult()\n          currentResult && processNextResult(currentResult)\n          return refetchResult\n        })\n    }\n  }\n\n  // Fetch more\n\n  function fetchMore (options: FetchMoreQueryOptions<TVariables, TResult> & FetchMoreOptions<TResult, TVariables>) {\n    if (query.value) {\n      error.value = null\n      loading.value = true\n      return query.value.fetchMore(options)\n        .then((fetchMoreResult) => {\n          const currentResult = query.value?.getCurrentResult()\n          currentResult && processNextResult(currentResult)\n          return fetchMoreResult\n        })\n    }\n  }\n\n  // Subscribe to more\n\n  const subscribeToMoreItems: SubscribeToMoreItem[] = []\n\n  function subscribeToMore<\n    TSubscriptionVariables = OperationVariables,\n    TSubscriptionData = TResult\n  > (\n    options: SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData> |\n    Ref<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>> |\n    ReactiveFunction<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>>,\n  ) {\n    if (isServer) return\n    const optionsRef = paramToRef(options)\n    watch(optionsRef, (value, oldValue, onCleanup) => {\n      const index = subscribeToMoreItems.findIndex(item => item.options === oldValue)\n      if (index !== -1) {\n        subscribeToMoreItems.splice(index, 1)\n      }\n      const item: SubscribeToMoreItem = {\n        options: value,\n        unsubscribeFns: [],\n      }\n      subscribeToMoreItems.push(item)\n\n      addSubscribeToMore(item)\n\n      onCleanup(() => {\n        item.unsubscribeFns.forEach(fn => fn())\n        item.unsubscribeFns = []\n      })\n    }, {\n      immediate: true,\n    })\n  }\n\n  function addSubscribeToMore (item: SubscribeToMoreItem) {\n    if (!started) return\n    if (!query.value) {\n      throw new Error('Query is not defined')\n    }\n    const unsubscribe = query.value.subscribeToMore(item.options)\n    onStopHandlers.push(unsubscribe)\n    item.unsubscribeFns.push(unsubscribe)\n  }\n\n  // Enabled state\n\n  const forceDisabled = ref(lazy)\n  const enabledOption = computed(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled)\n  const isEnabled = computed(() => enabledOption.value && !forceDisabled.value)\n\n  // Auto start & stop\n  watch(isEnabled, value => {\n    if (value) {\n      start()\n    } else {\n      stop()\n    }\n  }, {\n    immediate: true,\n  })\n\n  // Teardown\n  vm && onBeforeUnmount(() => {\n    stop()\n    subscribeToMoreItems.length = 0\n  })\n\n  return {\n    result,\n    loading,\n    networkStatus,\n    error,\n    start,\n    stop,\n    restart,\n    forceDisabled,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    query,\n    refetch,\n    fetchMore,\n    subscribeToMore,\n    onResult: resultEvent.on,\n    onError: errorEvent.on,\n  }\n}\n", "import { getCurrentInstance, inject } from 'vue-demi'\nimport { ApolloClient } from '@apollo/client/core'\n\nexport const DefaultApolloClient = Symbol('default-apollo-client')\nexport const ApolloClients = Symbol('apollo-clients')\n\ntype ClientId = string\ntype ClientDict<T> = Record<ClientId, ApolloClient<T>>\n\ntype ResolveClient<TCacheShape, TReturn = ApolloClient<TCacheShape>> = (clientId?: ClientId) => TReturn\ntype NullableApolloClient<TCacheShape> = ApolloClient<TCacheShape> | undefined\n\nexport interface UseApolloClientReturn<TCacheShape> {\n  resolveClient: ResolveClient<TCacheShape>\n  readonly client: ApolloClient<TCacheShape>\n}\n\nfunction resolveDefaultClient<T> (providedApolloClients: ClientDict<T> | null, providedApolloClient: ApolloClient<T> | null): NullableApolloClient<T> {\n  const resolvedClient = providedApolloClients\n    ? providedApolloClients.default\n    : (providedApolloClient ?? undefined)\n  return resolvedClient\n}\n\nfunction resolveClientWithId<T> (providedApolloClients: ClientDict<T> | null, clientId: ClientId): NullableApolloClient<T> {\n  if (!providedApolloClients) {\n    throw new Error(`No apolloClients injection found, tried to resolve '${clientId}' clientId`)\n  }\n  return providedApolloClients[clientId]\n}\n\nexport function useApolloClient<TCacheShape = any> (clientId?: ClientId): UseApolloClientReturn<TCacheShape> {\n  let resolveImpl: ResolveClient<TCacheShape, NullableApolloClient<TCacheShape>>\n\n  // Save current client in current closure scope\n  const savedCurrentClients = currentApolloClients\n\n  if (!getCurrentInstance()) {\n    resolveImpl = (id?: ClientId) => {\n      if (id) {\n        return resolveClientWithId(savedCurrentClients, id)\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default)\n    }\n  } else {\n    const providedApolloClients: ClientDict<TCacheShape> | null = inject(ApolloClients, null)\n    const providedApolloClient: ApolloClient<TCacheShape> | null = inject(DefaultApolloClient, null)\n\n    resolveImpl = (id?: ClientId) => {\n      if (id) {\n        const client = resolveClientWithId(providedApolloClients, id)\n        if (client) {\n          return client\n        }\n        return resolveClientWithId(savedCurrentClients, id)\n      }\n      const client = resolveDefaultClient(providedApolloClients, providedApolloClient)\n      if (client) {\n        return client\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default)\n    }\n  }\n\n  function resolveClient (id: ClientId | undefined = clientId) {\n    const client = resolveImpl(id)\n    if (!client) {\n      throw new Error(\n        `Apollo client with id ${\n          id ?? 'default'\n        } not found. Use provideApolloClient() if you are outside of a component setup.`,\n      )\n    }\n    return client\n  }\n\n  return {\n    resolveClient,\n    get client () {\n      return resolveClient()\n    },\n  }\n}\n\nlet currentApolloClients: ClientDict<any> = {}\n\nexport function provideApolloClient<TCacheShape = any> (client: ApolloClient<TCacheShape>) {\n  currentApolloClients = {\n    default: client,\n  }\n  return function <TFnResult = any> (fn: () => TFnResult) {\n    const result = fn()\n    currentApolloClients = {}\n    return result\n  }\n}\n\nexport function provideApolloClients<TCacheShape = any> (clients: ClientDict<TCacheShape>) {\n  currentApolloClients = clients\n  return function <TFnResult = any> (fn: () => TFnResult) {\n    const result = fn()\n    currentApolloClients = {}\n    return result\n  }\n}\n", "import { Ref, isRef, computed, ref } from 'vue-demi'\nimport { ReactiveFunction } from './ReactiveFunction'\n\nexport function paramToRef<T> (param: T | Ref<T> | ReactiveFunction<T>): Ref<T> {\n  if (isRef(param)) {\n    return param\n  } else if (typeof param === 'function') {\n    return computed(param as ReactiveFunction<T>)\n  } else {\n    return ref(param) as Ref<T>\n  }\n}\n", "import { Ref, isRef, reactive, computed } from 'vue-demi'\nimport { ReactiveFunction } from './ReactiveFunction'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype TObject = object\n\nexport function paramToReactive<T extends TObject> (param: T | Ref<T> | ReactiveFunction<T>): T | Ref<T> {\n  if (isRef(param)) {\n    return param\n  } else if (typeof param === 'function') {\n    return computed(param as ReactiveFunction<T>)\n  } else if (param) {\n    return reactive(param) as T\n  } else {\n    return param\n  }\n}\n", "export function useEventHook<TParam = any> () {\n  const fns: Array<(param: TParam) => void> = []\n\n  function on (fn: (param: TParam) => void) {\n    fns.push(fn)\n    return {\n      off: () => off(fn),\n    }\n  }\n\n  function off (fn: (param: TParam) => void) {\n    const index = fns.indexOf(fn)\n    if (index !== -1) {\n      fns.splice(index, 1)\n    }\n  }\n\n  function trigger (param: TParam) {\n    for (const fn of fns) {\n      fn(param)\n    }\n  }\n\n  function getCount () {\n    return fns.length\n  }\n\n  return {\n    on,\n    off,\n    trigger,\n    getCount,\n  }\n}\n", "import { Ref, watch, onUnmounted, ref, getCurrentInstance, onBeforeUnmount } from 'vue-demi'\nimport type { CurrentInstance } from './types'\n\nexport interface LoadingTracking {\n  queries: Ref<number>\n  mutations: Ref<number>\n  subscriptions: Ref<number>\n}\n\nexport interface AppLoadingTracking extends LoadingTracking {\n  components: Map<any, LoadingTracking>\n}\n\nexport function getAppTracking () {\n  const vm = getCurrentInstance() as CurrentInstance | null\n  const root = vm?.$root ?? vm?.root ?? vm?.proxy?.$root as CurrentInstance | null | undefined\n  if (!root) {\n    throw new Error('Instance $root not found')\n  }\n\n  let appTracking: AppLoadingTracking\n\n  if (!root._apolloAppTracking) {\n    // Add per Vue tracking\n    appTracking = root._apolloAppTracking = {\n      queries: ref(0),\n      mutations: ref(0),\n      subscriptions: ref(0),\n      components: new Map(),\n    }\n  } else {\n    appTracking = root._apolloAppTracking\n  }\n\n  return {\n    appTracking,\n  }\n}\n\nexport function getCurrentTracking () {\n  const vm = getCurrentInstance()\n  if (!vm) {\n    throw new Error('getCurrentTracking must be used during a component setup')\n  }\n\n  const { appTracking } = getAppTracking()\n\n  let tracking: LoadingTracking\n\n  if (!appTracking.components.has(vm)) {\n    // Add per-component tracking\n    appTracking.components.set(vm, tracking = {\n      queries: ref(0),\n      mutations: ref(0),\n      subscriptions: ref(0),\n    })\n    // Cleanup\n    onUnmounted(() => {\n      appTracking.components.delete(vm)\n    })\n  } else {\n    tracking = appTracking.components.get(vm) as LoadingTracking\n  }\n\n  return {\n    appTracking,\n    tracking,\n  }\n}\n\nfunction track (loading: Ref<boolean>, type: keyof LoadingTracking) {\n  const { appTracking, tracking } = getCurrentTracking()\n\n  watch(loading, (value, oldValue) => {\n    if (oldValue != null && value !== oldValue) {\n      const mod = value ? 1 : -1\n      tracking[type].value += mod\n      appTracking[type].value += mod\n    }\n  }, {\n    immediate: true,\n  })\n\n  onBeforeUnmount(() => {\n    if (loading.value) {\n      tracking[type].value--\n      appTracking[type].value--\n    }\n  })\n}\n\nexport function trackQuery (loading: Ref<boolean>) {\n  track(loading, 'queries')\n}\n\nexport function trackMutation (loading: Ref<boolean>) {\n  track(loading, 'mutations')\n}\n\nexport function trackSubscription (loading: Ref<boolean>) {\n  track(loading, 'subscriptions')\n}\n", "import { ApolloError, isApolloError } from '@apollo/client/core'\nimport { GraphQLErrors } from '@apollo/client/errors'\n\nexport function toApolloError (error: unknown): ApolloError {\n  if (!(error instanceof Error)) {\n    return new ApolloError({\n      networkError: Object.assign(new Error(), { originalError: error }),\n      errorMessage: String(error),\n    })\n  }\n\n  if (isApolloError(error)) {\n    return error\n  }\n\n  return new ApolloError({ networkError: error, errorMessage: error.message })\n}\n\nexport function resultErrorsToApolloError (errors: GraphQLErrors): ApolloError {\n  return new ApolloError({\n    graphQLErrors: errors,\n    errorMessage: `GraphQL response contains errors: ${errors.map((e: any) => e.message).join(' | ')}`,\n  })\n}\n", "export const isServer = typeof window === 'undefined'\n", "import { DocumentNode } from 'graphql'\nimport { isRef } from 'vue-demi'\nimport { useQueryImpl, DocumentParameter, VariablesParameter, OptionsParameter, UseQueryOptions } from './useQuery'\n\nexport function useLazyQuery<\n  TResult = any,\n  TVariables = any,\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables?: VariablesParameter<TVariables>,\n  options?: OptionsParameter<TResult, TVariables>,\n) {\n  const query = useQueryImpl<TResult, TVariables>(document, variables, options, true)\n\n  function load (\n    document?: DocumentNode,\n    variables?: TVariables,\n    options?: UseQueryOptions,\n  ) {\n    if (document) {\n      query.document.value = document\n    }\n    if (variables) {\n      query.variables.value = variables\n    }\n    if (options) {\n      Object.assign(isRef(query.options) ? query.options.value : query.options, options)\n    }\n    query.forceDisabled.value = false\n  }\n\n  return {\n    ...query,\n    load,\n  }\n}\n", "import { DocumentNode } from 'graphql'\nimport { MutationOptions, OperationVariables, FetchResult, TypedDocumentNode, ApolloError } from '@apollo/client/core'\nimport { ref, onBeforeUnmount, isRef, Ref, getCurrentInstance } from 'vue-demi'\nimport { useApolloClient } from './useApolloClient'\nimport { ReactiveFunction } from './util/ReactiveFunction'\nimport { useEventHook } from './util/useEventHook'\nimport { trackMutation } from './util/loadingTracking'\nimport { toApolloError } from './util/toApolloError'\n\n/**\n * `useMutation` options for mutations that don't require `variables`.\n */\nexport interface UseMutationOptions<\n  TResult = any,\n  TVariables = OperationVariables\n> extends Omit<MutationOptions<TResult, TVariables>, 'mutation'> {\n  clientId?: string\n  throws?: 'auto' | 'always' | 'never'\n}\n\ntype DocumentParameter<TResult, TVariables> = DocumentNode | Ref<DocumentNode> | ReactiveFunction<DocumentNode> | TypedDocumentNode<TResult, TVariables> | Ref<TypedDocumentNode<TResult, TVariables>> | ReactiveFunction<TypedDocumentNode<TResult, TVariables>>\ntype OptionsParameter<TResult, TVariables> = UseMutationOptions<TResult, TVariables> | Ref<UseMutationOptions<TResult, TVariables>> | ReactiveFunction<UseMutationOptions<TResult, TVariables>>\n\nexport type MutateOverrideOptions<TResult> = Pick<UseMutationOptions<TResult, OperationVariables>, 'update' | 'optimisticResponse' | 'context' | 'updateQueries' | 'refetchQueries' | 'awaitRefetchQueries' | 'errorPolicy' | 'fetchPolicy' | 'clientId'>\nexport type MutateResult<TResult> = Promise<FetchResult<TResult, Record<string, any>, Record<string, any>> | null>\nexport type MutateFunction<TResult, TVariables> = (variables?: TVariables | null, overrideOptions?: MutateOverrideOptions<TResult>) => MutateResult<TResult>\n\nexport interface UseMutationReturn<TResult, TVariables> {\n  mutate: MutateFunction<TResult, TVariables>\n  loading: Ref<boolean>\n  error: Ref<ApolloError | null>\n  called: Ref<boolean>\n  onDone: (fn: (param: FetchResult<TResult, Record<string, any>, Record<string, any>>) => void) => {\n    off: () => void\n  }\n  onError: (fn: (param: ApolloError) => void) => {\n    off: () => void\n  }\n}\n\nexport function useMutation<\n  TResult = any,\n  TVariables extends OperationVariables = OperationVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  options: OptionsParameter<TResult, TVariables> = {},\n): UseMutationReturn<TResult, TVariables> {\n  const vm = getCurrentInstance()\n  const loading = ref<boolean>(false)\n  vm && trackMutation(loading)\n  const error = ref<ApolloError | null>(null)\n  const called = ref<boolean>(false)\n\n  const doneEvent = useEventHook<FetchResult<TResult, Record<string, any>, Record<string, any>>>()\n  const errorEvent = useEventHook<ApolloError>()\n\n  // Apollo Client\n  const { resolveClient } = useApolloClient()\n\n  async function mutate (variables?: TVariables | null, overrideOptions: Omit<UseMutationOptions<TResult, TVariables>, 'variables'> = {}) {\n    let currentDocument: DocumentNode\n    if (typeof document === 'function') {\n      currentDocument = document()\n    } else if (isRef(document)) {\n      currentDocument = document.value\n    } else {\n      currentDocument = document\n    }\n\n    let currentOptions: UseMutationOptions<TResult, TVariables>\n    if (typeof options === 'function') {\n      currentOptions = options()\n    } else if (isRef(options)) {\n      currentOptions = options.value\n    } else {\n      currentOptions = options\n    }\n    const client = resolveClient(currentOptions.clientId)\n    error.value = null\n    loading.value = true\n    called.value = true\n    try {\n      const result = await client.mutate<TResult, TVariables>({\n        mutation: currentDocument,\n        ...currentOptions,\n        ...overrideOptions,\n        variables: (variables ?? currentOptions.variables)\n          ? {\n            ...(currentOptions.variables as TVariables),\n            ...(variables as TVariables),\n          }\n          : undefined,\n      })\n      loading.value = false\n      doneEvent.trigger(result)\n      return result\n    } catch (e) {\n      const apolloError = toApolloError(e)\n      error.value = apolloError\n      loading.value = false\n      errorEvent.trigger(apolloError)\n      if (currentOptions.throws === 'always' || (currentOptions.throws !== 'never' && !errorEvent.getCount())) {\n        throw apolloError\n      }\n    }\n    return null\n  }\n\n  vm && onBeforeUnmount(() => {\n    loading.value = false\n  })\n\n  return {\n    mutate,\n    loading,\n    error,\n    called,\n    onDone: doneEvent.on,\n    onError: errorEvent.on,\n  }\n}\n", "import { DocumentNode } from 'graphql'\nimport {\n  Ref,\n  ref,\n  watch,\n  isRef,\n  computed,\n  getCurrentInstance,\n  onBeforeUnmount,\n  nextTick,\n} from 'vue-demi'\nimport {\n  OperationVariables,\n  SubscriptionOptions,\n  FetchResult,\n  Observable,\n  ObservableSubscription,\n  TypedDocumentNode,\n  ApolloError,\n} from '@apollo/client/core'\nimport { throttle, debounce } from 'throttle-debounce'\nimport { ReactiveFunction } from './util/ReactiveFunction'\nimport { paramToRef } from './util/paramToRef'\nimport { paramToReactive } from './util/paramToReactive'\nimport { useApolloClient } from './useApolloClient'\nimport { useEventHook } from './util/useEventHook'\nimport { trackSubscription } from './util/loadingTracking'\nimport type { CurrentInstance } from './util/types'\nimport { toApolloError } from './util/toApolloError'\nimport { isServer } from './util/env'\n\nexport interface UseSubscriptionOptions <\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TResult = any,\n  TVariables = OperationVariables\n> extends Omit<SubscriptionOptions<TVariables>, 'query' | 'variables'> {\n  clientId?: string\n  enabled?: boolean\n  throttle?: number\n  debounce?: number\n}\n\ntype DocumentParameter<TResult, TVariables> = DocumentNode | Ref<DocumentNode> | ReactiveFunction<DocumentNode> | TypedDocumentNode<TResult, TVariables> | Ref<TypedDocumentNode<TResult, TVariables>> | ReactiveFunction<TypedDocumentNode<TResult, TVariables>>\ntype VariablesParameter<TVariables> = TVariables | Ref<TVariables> | ReactiveFunction<TVariables>\ntype OptionsParameter<TResult, TVariables> = UseSubscriptionOptions<TResult, TVariables> | Ref<UseSubscriptionOptions<TResult, TVariables>> | ReactiveFunction<UseSubscriptionOptions<TResult, TVariables>>\n\nexport interface UseSubscriptionReturn<TResult, TVariables> {\n  result: Ref<TResult | null | undefined>\n  loading: Ref<boolean>\n  error: Ref<ApolloError | null>\n  start: () => void\n  stop: () => void\n  restart: () => void\n  document: Ref<DocumentNode>\n  variables: Ref<TVariables | undefined>\n  options: UseSubscriptionOptions<TResult, TVariables> | Ref<UseSubscriptionOptions<TResult, TVariables>>\n  subscription: Ref<Observable<FetchResult<TResult, Record<string, any>, Record<string, any>>> | null>\n  onResult: (fn: (param: FetchResult<TResult, Record<string, any>, Record<string, any>>) => void) => {\n    off: () => void\n  }\n  onError: (fn: (param: ApolloError) => void) => {\n    off: () => void\n  }\n}\n\n/**\n * Use a subscription that does not require variables or options.\n * */\nexport function useSubscription<TResult = any> (\n  document: DocumentParameter<TResult, undefined>\n): UseSubscriptionReturn<TResult, undefined>\n\n/**\n * Use a subscription that requires options but not variables.\n */\nexport function useSubscription<TResult = any> (\n  document: DocumentParameter<TResult, undefined>,\n  variables: undefined | null,\n  options: OptionsParameter<TResult, null>\n): UseSubscriptionReturn<TResult, null>\n\n/**\n * Use a subscription that requires variables.\n */\nexport function useSubscription<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>\n): UseSubscriptionReturn<TResult, TVariables>\n\n/**\n * Use a subscription that has optional variables.\n */\nexport function useSubscription<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n): UseSubscriptionReturn<TResult, TVariables>\n\n/**\n * Use a subscription that requires variables and options.\n */\nexport function useSubscription<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>,\n  options: OptionsParameter<TResult, TVariables>\n): UseSubscriptionReturn<TResult, TVariables>\n\nexport function useSubscription <\n  TResult,\n  TVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables> | undefined = undefined,\n  options: OptionsParameter<TResult, TVariables> = {},\n): UseSubscriptionReturn<TResult, TVariables> {\n  // Is on server?\n  const vm = getCurrentInstance() as CurrentInstance | null\n\n  const documentRef = paramToRef(document)\n  const variablesRef = paramToRef(variables)\n  const optionsRef = paramToReactive(options)\n\n  const result = ref<TResult | null | undefined>()\n  const resultEvent = useEventHook<FetchResult<TResult>>()\n  const error = ref<ApolloError | null>(null)\n  const errorEvent = useEventHook<ApolloError>()\n\n  const loading = ref(false)\n  vm && trackSubscription(loading)\n\n  // Apollo Client\n  const { resolveClient } = useApolloClient()\n\n  const subscription: Ref<Observable<FetchResult<TResult>> | null> = ref(null)\n  let observer: ObservableSubscription | null = null\n  let started = false\n\n  function start () {\n    if (started || !isEnabled.value || isServer) return\n    started = true\n    loading.value = true\n\n    const client = resolveClient(currentOptions.value?.clientId)\n\n    subscription.value = client.subscribe<TResult, TVariables>({\n      query: currentDocument,\n      variables: currentVariables,\n      ...currentOptions.value,\n    })\n\n    observer = subscription.value.subscribe({\n      next: onNextResult,\n      error: onError,\n    })\n  }\n\n  function onNextResult (fetchResult: FetchResult<TResult>) {\n    result.value = fetchResult.data\n    loading.value = false\n    resultEvent.trigger(fetchResult)\n  }\n\n  function onError (fetchError: unknown) {\n    const apolloError = toApolloError(fetchError)\n\n    error.value = apolloError\n    loading.value = false\n    errorEvent.trigger(apolloError)\n  }\n\n  function stop () {\n    if (!started) return\n    started = false\n    loading.value = false\n\n    if (subscription.value) {\n      subscription.value = null\n    }\n\n    if (observer) {\n      observer.unsubscribe()\n      observer = null\n    }\n  }\n\n  // Restart\n  let restarting = false\n  /**\n   * Queue a restart of the query (on next tick) if it is already active\n   */\n  function baseRestart () {\n    if (!started || restarting) return\n    restarting = true\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    nextTick(() => {\n      if (started) {\n        stop()\n        start()\n      }\n      restarting = false\n    })\n  }\n\n  let debouncedRestart: typeof baseRestart\n  function updateRestartFn () {\n    if (currentOptions.value?.throttle) {\n      debouncedRestart = throttle(currentOptions.value.throttle, baseRestart)\n    } else if (currentOptions.value?.debounce) {\n      debouncedRestart = debounce(currentOptions.value.debounce, baseRestart)\n    } else {\n      debouncedRestart = baseRestart\n    }\n  }\n\n  function restart () {\n    if (!debouncedRestart) updateRestartFn()\n    debouncedRestart()\n  }\n\n  // Applying options\n  const currentOptions = ref<UseSubscriptionOptions<TResult, TVariables>>()\n  watch(() => isRef(optionsRef) ? optionsRef.value : optionsRef, value => {\n    if (currentOptions.value && (\n      currentOptions.value.throttle !== value.throttle ||\n      currentOptions.value.debounce !== value.debounce\n    )) {\n      updateRestartFn()\n    }\n    currentOptions.value = value\n    restart()\n  }, {\n    deep: true,\n    immediate: true,\n  })\n\n  // Applying document\n  let currentDocument: DocumentNode\n  watch(documentRef, value => {\n    currentDocument = value\n    restart()\n  }, {\n    immediate: true,\n  })\n\n  // Applying variables\n  let currentVariables: TVariables | undefined\n  let currentVariablesSerialized: string\n  watch(variablesRef, (value, oldValue) => {\n    const serialized = JSON.stringify(value)\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value\n      restart()\n    }\n    currentVariablesSerialized = serialized\n  }, {\n    deep: true,\n    immediate: true,\n  })\n\n  // Internal enabled returned to user\n  // @TODO Doesn't fully work yet, need to initialize with option\n  // const enabled = ref<boolean>()\n  const enabledOption = computed(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled)\n  // const isEnabled = computed(() => !!((typeof enabled.value === 'boolean' && enabled.value) && enabledOption.value))\n  const isEnabled = enabledOption\n\n  // watch(enabled, value => {\n  //   if (value == null) {\n  //     enabled.value = enabledOption.value\n  //   }\n  // })\n\n  // Auto start & stop\n  watch(isEnabled, value => {\n    if (value) {\n      start()\n    } else {\n      stop()\n    }\n  }, {\n    immediate: true,\n  })\n\n  // Teardown\n  vm && onBeforeUnmount(stop)\n\n  return {\n    result,\n    loading,\n    error,\n    // @TODO doesn't fully work yet\n    // enabled,\n    start,\n    stop,\n    restart,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    subscription,\n    onResult: resultEvent.on,\n    onError: errorEvent.on,\n  }\n}\n", "import { Ref, computed } from 'vue-demi'\nimport { ExtractSingleKey } from './util/ExtractSingleKey'\nimport type { DeepNonNullable, DeepRequired } from 'ts-essentials'\n\nexport type UseResultReturn<T> = Readonly<Ref<Readonly<T>>>\n\n/**\n * Resolve a `result`, returning either the first key of the `result` if there\n * is only one, or the `result` itself. The `value` of the ref will be\n * `undefined` until it is resolved.\n *\n * @example\n * const { result } = useQuery(...)\n * const user = useResult(result)\n * // user is `undefined` until the query resolves\n *\n * @param  {Ref<TResult>} result A `result` returned from `useQuery` to resolve.\n * @returns Readonly ref with `undefined` or the resolved `result`.\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<TResult, TResultKey extends keyof NonNullable<TResult> = keyof NonNullable<TResult>> (\n  result: Ref<TResult>\n): UseResultReturn<undefined | ExtractSingleKey<NonNullable<TResult>, TResultKey>>\n\n/**\n * Resolve a `result`, returning either the first key of the `result` if there\n * is only one, or the `result` itself. The `value` of the ref will be\n * `defaultValue` until it is resolved.\n *\n * @example\n * const { result } = useQuery(...)\n * const profile = useResult(result, {})\n * // profile is `{}` until the query resolves\n *\n * @param  {Ref<TResult>} result A `result` returned from `useQuery` to resolve.\n * @param  {TDefaultValue} defaultValue The default return value before `result` is resolved.\n * @returns Readonly ref with the `defaultValue` or the resolved `result`.\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<TResult, TDefaultValue, TResultKey extends keyof NonNullable<TResult> = keyof NonNullable<TResult>> (\n  result: Ref<TResult>,\n  defaultValue: TDefaultValue\n): UseResultReturn<TDefaultValue | ExtractSingleKey<NonNullable<TResult>, TResultKey>>\n\n/**\n * Resolve a `result`, returning the `result` mapped with the `pick` function.\n * The `value` of the ref will be `defaultValue` until it is resolved.\n *\n * @example\n * const { result } = useQuery(...)\n * const comments = useResult(result, undefined, (data) => data.comments)\n * // user is `undefined`, then resolves to the result's `comments`\n *\n * @param  {Ref<TResult>} result A `result` returned from `useQuery` to resolve.\n * @param  {TDefaultValue} defaultValue The default return value before `result` is resolved.\n * @param  {(data:TResult)=>TReturnValue} pick The function that receives `result` and maps a return value from it.\n * @returns Readonly ref with the `defaultValue` or the resolved and `pick`-mapped `result`\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<\n  TResult,\n  TDefaultValue,\n  TReturnValue,\n> (\n  result: Ref<TResult>,\n  defaultValue: TDefaultValue | undefined,\n  pick: (data: DeepRequired<DeepNonNullable<TResult>>) => TReturnValue\n): UseResultReturn<TDefaultValue | TReturnValue>\n\n/**\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<\n  TResult,\n  TDefaultValue,\n  TReturnValue,\n> (\n  result: Ref<TResult>,\n  defaultValue?: TDefaultValue,\n  pick?: (data: DeepRequired<DeepNonNullable<TResult>>) => TReturnValue,\n): UseResultReturn<TResult | TResult[keyof TResult] | TDefaultValue | TReturnValue | undefined> {\n  console.warn(`'useResult' is deprecated and will be removed soon. Plase use a computed instead.\nBefore:\nconst items = useResult(result, [], data => data.someField.myItems)\nAfter:\nconst items = computed(() => result.value?.someField.myItems ?? [])`)\n  return computed(() => {\n    const value = result.value\n    if (value) {\n      if (pick) {\n        try {\n          return pick(value as DeepRequired<DeepNonNullable<TResult>>)\n        } catch (e) {\n          // Silent error\n        }\n      } else {\n        const keys = Object.keys(value)\n        if (keys.length === 1) {\n          // Automatically take the only key in result data\n          return value[keys[0] as keyof TResult]\n        } else {\n          // Return entire result data\n          return value\n        }\n      }\n    }\n    return defaultValue\n  })\n}\n", "import { getCurrentTracking, getAppTracking } from './util/loadingTracking'\nimport { computed } from 'vue-demi'\n\nexport function useQueryLoading () {\n  const { tracking } = getCurrentTracking()\n  return computed(() => tracking.queries.value > 0)\n}\n\nexport function useMutationLoading () {\n  const { tracking } = getCurrentTracking()\n  return computed(() => tracking.mutations.value > 0)\n}\n\nexport function useSubscriptionLoading () {\n  const { tracking } = getCurrentTracking()\n  return computed(() => tracking.subscriptions.value > 0)\n}\n\nexport function useGlobalQueryLoading () {\n  const { appTracking } = getAppTracking()\n  return computed(() => appTracking.queries.value > 0)\n}\n\nexport function useGlobalMutationLoading () {\n  const { appTracking } = getAppTracking()\n  return computed(() => appTracking.mutations.value > 0)\n}\n\nexport function useGlobalSubscriptionLoading () {\n  const { appTracking } = getAppTracking()\n  return computed(() => appTracking.subscriptions.value > 0)\n}\n"],
  "mappings": "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",
  "names": ["delay", "noTrailing", "callback", "debounceMode", "timeoutID", "cancelled", "lastExec", "clearExistingTimeout", "clearTimeout", "cancel", "undefined", "wrapper", "arguments_", "self", "elapsed", "Date", "now", "exec", "apply", "clear", "setTimeout", "atBegin", "throttle"]
}

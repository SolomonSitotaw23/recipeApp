{
  "version": 3,
  "sources": ["../../ts-invariant/src/invariant.ts", "../../@apollo/src/utilities/globals/maybe.ts", "../../@apollo/src/utilities/globals/global.ts", "../../@apollo/src/utilities/globals/DEV.ts", "../../ts-invariant/process/index.js", "../../@apollo/src/utilities/globals/fix-graphql.ts", "../../@apollo/src/utilities/globals/index.ts", "../../@apollo/src/utilities/common/objects.ts", "../../@apollo/src/utilities/graphql/fragments.ts", "../../@apollo/src/utilities/graphql/storeUtils.ts", "../../zen-observable-ts/module.js", "../../symbol-observable/es/ponyfill.js", "../../symbol-observable/es/index.js", "../../@apollo/src/utilities/observables/Observable.ts", "../../@apollo/src/utilities/common/compact.ts", "../../@apollo/src/utilities/common/mergeOptions.ts", "../../@apollo/src/utilities/graphql/directives.ts", "../../@apollo/src/utilities/graphql/getFromAST.ts", "../../@apollo/src/utilities/common/filterInPlace.ts", "../../@apollo/src/utilities/graphql/transform.ts", "../../@apollo/src/utilities/common/mergeDeep.ts", "../../@apollo/src/utilities/common/cloneDeep.ts", "../../@apollo/src/utilities/common/maybeDeepFreeze.ts", "../../@apollo/src/utilities/observables/iteration.ts", "../../@apollo/src/utilities/observables/asyncMap.ts", "../../@apollo/src/utilities/common/canUse.ts", "../../@apollo/src/utilities/observables/subclassing.ts", "../../@apollo/src/utilities/observables/Concast.ts", "../../@apollo/src/utilities/common/arrays.ts", "../../@apollo/src/utilities/common/errorHandling.ts", "../../@apollo/src/utilities/common/makeUniqueId.ts", "../../@apollo/src/utilities/common/stringifyForDisplay.ts", "../../@apollo/src/link/utils/fromError.ts", "../../@apollo/src/link/utils/toPromise.ts", "../../@apollo/src/link/utils/fromPromise.ts", "../../@apollo/src/link/utils/throwServerError.ts", "../../@apollo/src/link/utils/validateOperation.ts", "../../@apollo/src/link/utils/createOperation.ts", "../../@apollo/src/link/utils/transformOperation.ts", "../../@apollo/src/link/core/ApolloLink.ts", "../../@apollo/src/link/core/empty.ts", "../../@apollo/src/link/core/from.ts", "../../@apollo/src/link/core/split.ts", "../../@apollo/src/link/core/concat.ts", "../../@apollo/src/link/core/execute.ts"],
  "sourcesContent": ["const genericMessage = \"Invariant Violation\";\nconst {\n  setPrototypeOf = function (obj: any, proto: any) {\n    obj.__proto__ = proto;\n    return obj;\n  },\n} = Object as any;\n\nexport class InvariantError extends Error {\n  framesToPop = 1;\n  name = genericMessage;\n  constructor(message: string | number = genericMessage) {\n    super(\n      typeof message === \"number\"\n        ? `${genericMessage}: ${message} (see https://github.com/apollographql/invariant-packages)`\n        : message\n    );\n    setPrototypeOf(this, InvariantError.prototype);\n  }\n}\n\nexport function invariant(\n  condition: any,\n  message?: string | number,\n): asserts condition {\n  if (!condition) {\n    throw new InvariantError(message);\n  }\n}\n\nconst verbosityLevels = [\"debug\", \"log\", \"warn\", \"error\", \"silent\"] as const;\nexport type VerbosityLevel = (typeof verbosityLevels)[number];\nexport type ConsoleMethodName = Exclude<VerbosityLevel, \"silent\">;\nlet verbosityLevel = verbosityLevels.indexOf(\"log\");\n\nfunction wrapConsoleMethod<M extends ConsoleMethodName>(name: M) {\n  return function () {\n    if (verbosityLevels.indexOf(name) >= verbosityLevel) {\n      // Default to console.log if this host environment happens not to provide\n      // all the console.* methods we need.\n      const method = console[name] || console.log;\n      return method.apply(console, arguments as any);\n    }\n  } as (typeof console)[M];\n}\n\nexport namespace invariant {\n  export const debug = wrapConsoleMethod(\"debug\");\n  export const log = wrapConsoleMethod(\"log\");\n  export const warn = wrapConsoleMethod(\"warn\");\n  export const error = wrapConsoleMethod(\"error\");\n}\n\nexport function setVerbosity(level: VerbosityLevel): VerbosityLevel {\n  const old = verbosityLevels[verbosityLevel];\n  verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));\n  return old;\n}\n\nexport default invariant;\n", "export function maybe<T>(thunk: () => T): T | undefined {\n  try { return thunk() } catch {}\n}\n", "import { maybe } from \"./maybe\";\n\ndeclare global {\n  // Despite our attempts to reuse the React Native __DEV__ constant instead of\n  // inventing something new and Apollo-specific, declaring a useful type for\n  // __DEV__ unfortunately conflicts (TS2451) with the global declaration in\n  // @types/react-native/index.d.ts.\n  //\n  // To hide that harmless conflict, we @ts-ignore this line, which should\n  // continue to provide a type for __DEV__ elsewhere in the Apollo Client\n  // codebase, even when @types/react-native is not in use.\n  //\n  // However, because TypeScript drops @ts-ignore comments when generating .d.ts\n  // files (https://github.com/microsoft/TypeScript/issues/38628), we also\n  // sanitize the dist/utilities/globals/global.d.ts file to avoid declaring\n  // __DEV__ globally altogether when @apollo/client is installed in the\n  // node_modules directory of an application.\n  //\n  // @ts-ignore\n  const __DEV__: boolean | undefined;\n}\n\nexport default (\n  maybe(() => globalThis) ||\n  maybe(() => window) ||\n  maybe(() => self) ||\n  maybe(() => global) ||\n  // We don't expect the Function constructor ever to be invoked at runtime, as\n  // long as at least one of globalThis, window, self, or global is defined, so\n  // we are under no obligation to make it easy for static analysis tools to\n  // detect syntactic usage of the Function constructor. If you think you can\n  // improve your static analysis to detect this obfuscation, think again. This\n  // is an arms race you cannot win, at least not in JavaScript.\n  maybe(function() { return maybe.constructor(\"return this\")() })\n) as typeof globalThis & {\n  __DEV__: typeof __DEV__;\n};\n", "import global from \"./global\";\nimport { maybe } from \"./maybe\";\n\n// To keep string-based find/replace minifiers from messing with __DEV__ inside\n// string literals or properties like global.__DEV__, we construct the \"__DEV__\"\n// string in a roundabout way that won't be altered by find/replace strategies.\nconst __ = \"__\";\nconst GLOBAL_KEY = [__, __].join(\"DEV\");\n\nfunction getDEV() {\n  try {\n    return Boolean(__DEV__);\n  } catch {\n    Object.defineProperty(global, GLOBAL_KEY, {\n      // In a buildless browser environment, maybe(() => process.env.NODE_ENV)\n      // evaluates as undefined, so __DEV__ becomes true by default, but can be\n      // initialized to false instead by a script/module that runs earlier.\n      value: maybe(() => process.env.NODE_ENV) !== \"production\",\n      enumerable: false,\n      configurable: true,\n      writable: true,\n    });\n    // Using computed property access rather than global.__DEV__ here prevents\n    // string-based find/replace strategies from munging this to global.false:\n    return (global as any)[GLOBAL_KEY];\n  }\n}\n\nexport default getDEV();\n", "function maybe(thunk) {\n  try { return thunk() } catch (_) {}\n}\n\nvar safeGlobal = (\n  maybe(function() { return globalThis }) ||\n  maybe(function() { return window }) ||\n  maybe(function() { return self }) ||\n  maybe(function() { return global }) ||\n  // We don't expect the Function constructor ever to be invoked at runtime, as\n  // long as at least one of globalThis, window, self, or global is defined, so\n  // we are under no obligation to make it easy for static analysis tools to\n  // detect syntactic usage of the Function constructor. If you think you can\n  // improve your static analysis to detect this obfuscation, think again. This\n  // is an arms race you cannot win, at least not in JavaScript.\n  maybe(function() { return maybe.constructor(\"return this\")() })\n);\n\nvar needToRemove = false;\n\nexport function install() {\n  if (safeGlobal &&\n      !maybe(function() { return process.env.NODE_ENV }) &&\n      !maybe(function() { return process })) {\n    Object.defineProperty(safeGlobal, \"process\", {\n      value: {\n        env: {\n          // This default needs to be \"production\" instead of \"development\", to\n          // avoid the problem https://github.com/graphql/graphql-js/pull/2894\n          // will eventually solve, once merged and released.\n          NODE_ENV: \"production\",\n        },\n      },\n      // Let anyone else change global.process as they see fit, but hide it from\n      // Object.keys(global) enumeration.\n      configurable: true,\n      enumerable: false,\n      writable: true,\n    });\n    needToRemove = true;\n  }\n}\n\n// Call install() at least once, when this module is imported.\ninstall();\n\nexport function remove() {\n  if (needToRemove) {\n    delete safeGlobal.process;\n    needToRemove = false;\n  }\n}\n", "// The ordering of these imports is important, because it ensures the temporary\n// process.env.NODE_ENV polyfill is defined globally (if necessary) before we\n// import { Source } from 'graphql'. The instanceOf function that we really care\n// about (the one that uses process.env.NODE_ENV) is not exported from the\n// top-level graphql package, but graphql/language/source uses instanceOf, and\n// has relatively few dependencies, so importing it here should not increase\n// bundle sizes as much as other options.\nimport { remove } from 'ts-invariant/process';\nimport { Source } from 'graphql';\n\nexport function removeTemporaryGlobals() {\n  // Using Source here here just to make sure it won't be tree-shaken away.\n  return typeof Source === \"function\" ? remove() : remove();\n}\n", "import { invariant, InvariantError } from \"ts-invariant\";\n\n// Just in case the graphql package switches from process.env.NODE_ENV to\n// __DEV__, make sure __DEV__ is polyfilled before importing graphql.\nimport DEV from \"./DEV\";\nexport { DEV }\nexport function checkDEV() {\n  invariant(\"boolean\" === typeof DEV, DEV);\n}\n\n// Import graphql/jsutils/instanceOf safely, working around its unchecked usage\n// of process.env.NODE_ENV and https://github.com/graphql/graphql-js/pull/2894.\nimport { removeTemporaryGlobals } from \"./fix-graphql\";\n\n// Synchronously undo the global process.env.NODE_ENV polyfill that we created\n// temporarily while importing the offending graphql/jsutils/instanceOf module.\nremoveTemporaryGlobals();\n\nexport { maybe } from \"./maybe\";\nexport { default as global } from \"./global\";\nexport { invariant, InvariantError }\n\n// Ensure __DEV__ was properly initialized, and prevent tree-shaking bundlers\n// from mistakenly pruning the ./DEV module (see issue #8674).\ncheckDEV();\n", "export function isNonNullObject(obj: any): obj is Record<string | number, any> {\n  return obj !== null && typeof obj === 'object';\n}\n", "import { invariant, InvariantError } from '../globals';\n\nimport {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionNode,\n} from 'graphql';\n\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype Kind = any;\ntype OperationTypeNode = any;\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nexport function getFragmentQueryDocument(\n  document: DocumentNode,\n  fragmentName?: string,\n): DocumentNode {\n  let actualFragmentName = fragmentName;\n\n  // Build an array of all our fragment definitions that will be used for\n  // validations. We also do some validations on the other definitions in the\n  // document while building this list.\n  const fragments: Array<FragmentDefinitionNode> = [];\n  document.definitions.forEach(definition => {\n    // Throw an error if we encounter an operation definition because we will\n    // define our own operation definition later on.\n    if (definition.kind === 'OperationDefinition') {\n      throw new InvariantError(\n        `Found a ${definition.operation} operation${\n          definition.name ? ` named '${definition.name.value}'` : ''\n        }. ` +\n          'No operations are allowed when using a fragment as a query. Only fragments are allowed.',\n      );\n    }\n    // Add our definition to the fragments array if it is a fragment\n    // definition.\n    if (definition.kind === 'FragmentDefinition') {\n      fragments.push(definition);\n    }\n  });\n\n  // If the user did not give us a fragment name then let us try to get a\n  // name from a single fragment in the definition.\n  if (typeof actualFragmentName === 'undefined') {\n    invariant(\n      fragments.length === 1,\n      `Found ${\n        fragments.length\n      } fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n    );\n    actualFragmentName = fragments[0].name.value;\n  }\n\n  // Generate a query document with an operation that simply spreads the\n  // fragment inside of it.\n  const query: DocumentNode = {\n    ...document,\n    definitions: [\n      {\n        kind: 'OperationDefinition' as Kind,\n        // OperationTypeNode is an enum\n        operation: 'query' as OperationTypeNode,\n        selectionSet: {\n          kind: 'SelectionSet' as Kind,\n          selections: [\n            {\n              kind: 'FragmentSpread' as Kind,\n              name: {\n                kind: 'Name' as Kind,\n                value: actualFragmentName,\n              },\n            },\n          ],\n        },\n      },\n      ...document.definitions,\n    ],\n  };\n\n  return query;\n}\n\n/**\n * This is an interface that describes a map from fragment names to fragment definitions.\n */\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(\n  fragments: FragmentDefinitionNode[] = [],\n): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach(fragment => {\n    symTable[fragment.name.value] = fragment;\n  });\n  return symTable;\n}\n\nexport function getFragmentFromSelection(\n  selection: SelectionNode,\n  fragmentMap?: FragmentMap,\n): InlineFragmentNode | FragmentDefinitionNode | null {\n  switch (selection.kind) {\n    case 'InlineFragment':\n      return selection;\n    case 'FragmentSpread': {\n      const fragment = fragmentMap && fragmentMap[selection.name.value];\n      invariant(fragment, `No fragment named ${selection.name.value}.`);\n      return fragment!;\n    }\n    default:\n      return null;\n  }\n}\n", "import { InvariantError } from '../globals';\n\nimport {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n  SelectionSetNode,\n  DocumentNode,\n} from 'graphql';\n\nimport { isNonNullObject } from '../common/objects';\nimport { FragmentMap, getFragmentFromSelection } from './fragments';\n\nexport interface Reference {\n  readonly __ref: string;\n}\n\nexport function makeReference(id: string): Reference {\n  return { __ref: String(id) };\n}\n\nexport function isReference(obj: any): obj is Reference {\n  return Boolean(obj && typeof obj === 'object' && typeof obj.__ref === 'string');\n}\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | Reference\n  | Reference[]\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport interface StoreObject {\n  __typename?: string;\n  [storeFieldName: string]: StoreValue;\n}\n\nexport function isDocumentNode(value: any): value is DocumentNode {\n  return (\n    isNonNullObject(value) &&\n    (value as DocumentNode).kind === \"Document\" &&\n    Array.isArray((value as DocumentNode).definitions)\n  );\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === 'NullValue';\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object,\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map(obj =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables),\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(listValue => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables,\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw new InvariantError(\n      `The inline argument \"${name.value}\" of kind \"${(value as any).kind}\"` +\n        'is not supported. Use variables instead of inline arguments to ' +\n        'overcome this limitation.',\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object,\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(directive => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables,\n          ),\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  'connection',\n  'include',\n  'skip',\n  'client',\n  'rest',\n  'export',\n];\n\nexport const getStoreKeyName = Object.assign(function (\n  fieldName: string,\n  args?: Record<string, any> | null,\n  directives?: Directives,\n): string {\n  if (\n    args &&\n    directives &&\n    directives['connection'] &&\n    directives['connection']['key']\n  ) {\n    if (\n      directives['connection']['filter'] &&\n      (directives['connection']['filter'] as string[]).length > 0\n    ) {\n      const filterKeys = directives['connection']['filter']\n        ? (directives['connection']['filter'] as string[])\n        : [];\n      filterKeys.sort();\n\n      const filteredArgs = {} as { [key: string]: any };\n      filterKeys.forEach(key => {\n        filteredArgs[key] = args[key];\n      });\n\n      return `${directives['connection']['key']}(${stringify(\n        filteredArgs,\n      )})`;\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  let completeFieldName: string = fieldName;\n\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    const stringifiedArgs: string = stringify(args);\n    completeFieldName += `(${stringifiedArgs})`;\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(key => {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += `@${key}(${stringify(directives[key])})`;\n      } else {\n        completeFieldName += `@${key}`;\n      }\n    });\n  }\n\n  return completeFieldName;\n}, {\n  setStringify(s: typeof stringify) {\n    const previous = stringify;\n    stringify = s;\n    return previous;\n  },\n});\n\n// Default stable JSON.stringify implementation. Can be updated/replaced with\n// something better by calling getStoreKeyName.setStringify.\nlet stringify = function defaultStringify(value: any): string {\n  return JSON.stringify(value, stringifyReplacer);\n};\n\nfunction stringifyReplacer(_key: string, value: any): any {\n  if (isNonNullObject(value) && !Array.isArray(value)) {\n    value = Object.keys(value).sort().reduce((copy, key) => {\n      copy[key] = value[key];\n      return copy;\n    }, {} as Record<string, any>);\n  }\n  return value;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables?: Record<string, any>,\n): Object | null {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n    return argObj;\n  }\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function getTypenameFromResult(\n  result: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  fragmentMap?: FragmentMap,\n): string | undefined {\n  if (typeof result.__typename === 'string') {\n    return result.__typename;\n  }\n\n  for (const selection of selectionSet.selections) {\n    if (isField(selection)) {\n      if (selection.name.value === '__typename') {\n        return result[resultKeyNameFromField(selection)];\n      }\n    } else {\n      const typename = getTypenameFromResult(\n        result,\n        getFragmentFromSelection(selection, fragmentMap)!.selectionSet,\n        fragmentMap,\n      );\n      if (typeof typename === 'string') {\n        return typename;\n      }\n    }\n  }\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === 'Field';\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode,\n): selection is InlineFragmentNode {\n  return selection.kind === 'InlineFragment';\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n", "function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n// === Symbol Support ===\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\n\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\n\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\nvar SymbolIterator = getSymbol('iterator');\nvar SymbolObservable = getSymbol('observable');\nvar SymbolSpecies = getSymbol('species'); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n  if (value == null) return undefined;\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({\n      type: type,\n      value: value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{\n      type: type,\n      value: value\n    }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription = /*#__PURE__*/function () {\n  function Subscription(observer, subscriber) {\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  var _proto = Subscription.prototype;\n\n  _proto.unsubscribe = function unsubscribe() {\n    if (this._state !== 'closed') {\n      closeSubscription(this);\n      cleanupSubscription(this);\n    }\n  };\n\n  _createClass(Subscription, [{\n    key: \"closed\",\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver = /*#__PURE__*/function () {\n  function SubscriptionObserver(subscription) {\n    this._subscription = subscription;\n  }\n\n  var _proto2 = SubscriptionObserver.prototype;\n\n  _proto2.next = function next(value) {\n    onNotify(this._subscription, 'next', value);\n  };\n\n  _proto2.error = function error(value) {\n    onNotify(this._subscription, 'error', value);\n  };\n\n  _proto2.complete = function complete() {\n    onNotify(this._subscription, 'complete');\n  };\n\n  _createClass(SubscriptionObserver, [{\n    key: \"closed\",\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable = /*#__PURE__*/function () {\n  function Observable(subscriber) {\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n    this._subscriber = subscriber;\n  }\n\n  var _proto3 = Observable.prototype;\n\n  _proto3.subscribe = function subscribe(observer) {\n    if (typeof observer !== 'object' || observer === null) {\n      observer = {\n        next: observer,\n        error: arguments[1],\n        complete: arguments[2]\n      };\n    }\n\n    return new Subscription(observer, this._subscriber);\n  };\n\n  _proto3.forEach = function forEach(fn) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (typeof fn !== 'function') {\n        reject(new TypeError(fn + ' is not a function'));\n        return;\n      }\n\n      function done() {\n        subscription.unsubscribe();\n        resolve();\n      }\n\n      var subscription = _this.subscribe({\n        next: function (value) {\n          try {\n            fn(value, done);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  };\n\n  _proto3.map = function map(fn) {\n    var _this2 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      return _this2.subscribe({\n        next: function (value) {\n          try {\n            value = fn(value);\n          } catch (e) {\n            return observer.error(e);\n          }\n\n          observer.next(value);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.filter = function filter(fn) {\n    var _this3 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      return _this3.subscribe({\n        next: function (value) {\n          try {\n            if (!fn(value)) return;\n          } catch (e) {\n            return observer.error(e);\n          }\n\n          observer.next(value);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.reduce = function reduce(fn) {\n    var _this4 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    var hasSeed = arguments.length > 1;\n    var hasValue = false;\n    var seed = arguments[1];\n    var acc = seed;\n    return new C(function (observer) {\n      return _this4.subscribe({\n        next: function (value) {\n          var first = !hasValue;\n          hasValue = true;\n\n          if (!first || hasSeed) {\n            try {\n              acc = fn(acc, value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          } else {\n            acc = value;\n          }\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n          observer.next(acc);\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.concat = function concat() {\n    var _this5 = this;\n\n    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n      sources[_key] = arguments[_key];\n    }\n\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      var subscription;\n      var index = 0;\n\n      function startNext(next) {\n        subscription = next.subscribe({\n          next: function (v) {\n            observer.next(v);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (index === sources.length) {\n              subscription = undefined;\n              observer.complete();\n            } else {\n              startNext(C.from(sources[index++]));\n            }\n          }\n        });\n      }\n\n      startNext(_this5);\n      return function () {\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = undefined;\n        }\n      };\n    });\n  };\n\n  _proto3.flatMap = function flatMap(fn) {\n    var _this6 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      var subscriptions = [];\n\n      var outer = _this6.subscribe({\n        next: function (value) {\n          if (fn) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          }\n\n          var inner = C.from(value).subscribe({\n            next: function (value) {\n              observer.next(value);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              var i = subscriptions.indexOf(inner);\n              if (i >= 0) subscriptions.splice(i, 1);\n              completeIfDone();\n            }\n          });\n          subscriptions.push(inner);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          completeIfDone();\n        }\n      });\n\n      function completeIfDone() {\n        if (outer.closed && subscriptions.length === 0) observer.complete();\n      }\n\n      return function () {\n        subscriptions.forEach(function (s) {\n          return s.unsubscribe();\n        });\n        outer.unsubscribe();\n      };\n    });\n  };\n\n  _proto3[SymbolObservable] = function () {\n    return this;\n  };\n\n  Observable.from = function from(x) {\n    var C = typeof this === 'function' ? this : Observable;\n    if (x == null) throw new TypeError(x + ' is not an object');\n    var method = getMethod(x, SymbolObservable);\n\n    if (method) {\n      var observable = method.call(x);\n      if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n      if (isObservable(observable) && observable.constructor === C) return observable;\n      return new C(function (observer) {\n        return observable.subscribe(observer);\n      });\n    }\n\n    if (hasSymbol('iterator')) {\n      method = getMethod(x, SymbolIterator);\n\n      if (method) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n\n            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;) {\n              var item = _step.value;\n              observer.next(item);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n    }\n\n    if (Array.isArray(x)) {\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n\n          for (var i = 0; i < x.length; ++i) {\n            observer.next(x[i]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n\n    throw new TypeError(x + ' is not observable');\n  };\n\n  Observable.of = function of() {\n    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      items[_key2] = arguments[_key2];\n    }\n\n    var C = typeof this === 'function' ? this : Observable;\n    return new C(function (observer) {\n      enqueue(function () {\n        if (observer.closed) return;\n\n        for (var i = 0; i < items.length; ++i) {\n          observer.next(items[i]);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    });\n  };\n\n  _createClass(Observable, null, [{\n    key: SymbolSpecies,\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}\n\nexport { Observable };\n", "export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\n\t\t\tif (typeof Symbol.for === 'function') {\n\t\t\t\t// This just needs to be something that won't trample other user's Symbol.for use\n\t\t\t\t// It also will guide people to the source of their issues, if this is problematic.\n\t\t\t\t// META: It's a resource locator!\n\t\t\t\tresult = Symbol.for('https://github.com/benlesh/symbol-observable');\n\t\t\t} else {\n\t\t\t\t// Symbol.for didn't exist! The best we can do at this point is a totally \n\t\t\t\t// unique symbol. Note that the string argument here is a descriptor, not\n\t\t\t\t// an identifier. This symbol is unique.\n\t\t\t\tresult = Symbol('https://github.com/benlesh/symbol-observable');\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tSymbol.observable = result;\n\t\t\t} catch (err) {\n\t\t\t\t// Do nothing. In some environments, users have frozen `Symbol` for security reasons,\n\t\t\t\t// if it is frozen assigning to it will throw. In this case, we don't care, because\n\t\t\t\t// they will need to use the returned value from the ponyfill.\n\t\t\t}\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n", "/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n", "import {\n  Observable,\n  Observer,\n  Subscription as ObservableSubscription,\n  Subscriber,\n} from 'zen-observable-ts';\n\n// This simplified polyfill attempts to follow the ECMAScript Observable\n// proposal (https://github.com/zenparsing/es-observable)\nimport 'symbol-observable';\n\nexport type {\n  Observer,\n  ObservableSubscription,\n  Subscriber,\n};\n\n// The zen-observable package defines Observable.prototype[Symbol.observable]\n// when Symbol is supported, but RxJS interop depends on also setting this fake\n// '@@observable' string as a polyfill for Symbol.observable.\nconst { prototype } = Observable;\nconst fakeObsSymbol = '@@observable' as keyof typeof prototype;\nif (!prototype[fakeObsSymbol]) {\n  prototype[fakeObsSymbol] = function () { return this; };\n}\n\nexport { Observable };\n", "import { TupleToIntersection } from './mergeDeep';\n\n/**\n * Merges the provided objects shallowly and removes\n * all properties with an `undefined` value\n */\nexport function compact<TArgs extends any[]>(\n  ...objects: TArgs\n): TupleToIntersection<TArgs> {\n  const result = Object.create(null);\n\n  objects.forEach(obj => {\n    if (!obj) return;\n    Object.keys(obj).forEach(key => {\n      const value = (obj as any)[key];\n      if (value !== void 0) {\n        result[key] = value;\n      }\n    });\n  });\n\n  return result;\n}\n", "import type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n} from \"../../core\";\n\nimport { compact } from \"./compact\";\n\ntype OptionsUnion<TData, TVariables, TContext> =\n  | WatchQueryOptions<TVariables, TData>\n  | QueryOptions<TVariables, TData>\n  | MutationOptions<TData, TVariables, TContext>;\n\nexport function mergeOptions<\n  TOptions extends OptionsUnion<any, any, any>\n>(\n  defaults: TOptions | Partial<TOptions> | undefined,\n  options: TOptions | Partial<TOptions>,\n): TOptions {\n  return compact(defaults, options, options.variables && {\n    variables: {\n      ...(defaults && defaults.variables),\n      ...options.variables,\n    },\n  });\n}\n", "import { invariant } from '../globals';\n\n// Provides the methods that allow QueryManager to handle the `skip` and\n// `include` directives within GraphQL.\nimport {\n  SelectionNode,\n  VariableNode,\n  BooleanValueNode,\n  DirectiveNode,\n  DocumentNode,\n  ArgumentNode,\n  ValueNode,\n  ASTNode,\n  visit,\n} from 'graphql';\n\nexport type DirectiveInfo = {\n  [fieldName: string]: { [argName: string]: any };\n};\n\nexport function shouldInclude(\n  { directives }: SelectionNode,\n  variables?: Record<string, any>,\n): boolean {\n  if (!directives || !directives.length) {\n    return true;\n  }\n  return getInclusionDirectives(\n    directives\n  ).every(({ directive, ifArgument }) => {\n    let evaledValue: boolean = false;\n    if (ifArgument.value.kind === 'Variable') {\n      evaledValue = variables && variables[(ifArgument.value as VariableNode).name.value];\n      invariant(\n        evaledValue !== void 0,\n        `Invalid variable referenced in @${directive.name.value} directive.`,\n      );\n    } else {\n      evaledValue = (ifArgument.value as BooleanValueNode).value;\n    }\n    return directive.name.value === 'skip' ? !evaledValue : evaledValue;\n  });\n}\n\nexport function getDirectiveNames(root: ASTNode) {\n  const names: string[] = [];\n\n  visit(root, {\n    Directive(node: DirectiveNode) {\n      names.push(node.name.value);\n    },\n  });\n\n  return names;\n}\n\nexport function hasDirectives(names: string[], root: ASTNode) {\n  return getDirectiveNames(root).some(\n    (name: string) => names.indexOf(name) > -1,\n  );\n}\n\nexport function hasClientExports(document: DocumentNode) {\n  return (\n    document &&\n    hasDirectives(['client'], document) &&\n    hasDirectives(['export'], document)\n  );\n}\n\nexport type InclusionDirectives = Array<{\n  directive: DirectiveNode;\n  ifArgument: ArgumentNode;\n}>;\n\nfunction isInclusionDirective({ name: { value } }: DirectiveNode): boolean {\n  return value === 'skip' || value === 'include';\n}\n\nexport function getInclusionDirectives(\n  directives: ReadonlyArray<DirectiveNode>,\n): InclusionDirectives {\n  const result: InclusionDirectives = [];\n\n  if (directives && directives.length) {\n    directives.forEach(directive => {\n      if (!isInclusionDirective(directive)) return;\n\n      const directiveArguments = directive.arguments;\n      const directiveName = directive.name.value;\n\n      invariant(\n        directiveArguments && directiveArguments.length === 1,\n        `Incorrect number of arguments for the @${directiveName} directive.`,\n      );\n\n      const ifArgument = directiveArguments![0];\n      invariant(\n        ifArgument.name && ifArgument.name.value === 'if',\n        `Invalid argument for the @${directiveName} directive.`,\n      );\n\n      const ifValue: ValueNode = ifArgument.value;\n\n      // means it has to be a variable value if this is a valid @skip or @include directive\n      invariant(\n        ifValue &&\n          (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'),\n        `Argument for the @${directiveName} directive must be a variable or a boolean value.`,\n      );\n\n      result.push({ directive, ifArgument });\n    });\n  }\n\n  return result;\n}\n\n", "import { invariant, InvariantError } from '../globals';\n\nimport {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from 'graphql';\n\nimport { valueToObjectRepresentation } from './storeUtils';\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  invariant(\n    doc && doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  const operations = doc.definitions\n    .filter(d => d.kind !== 'FragmentDefinition')\n    .map(definition => {\n      if (definition.kind !== 'OperationDefinition') {\n        throw new InvariantError(\n          `Schema type definitions not allowed in queries. Found: \"${\n            definition.kind\n          }\"`,\n        );\n      }\n      return definition;\n    });\n\n  invariant(\n    operations.length <= 1,\n    `Ambiguous GraphQL document: contains ${operations.length} operations`,\n  );\n\n  return doc;\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    definition => definition.kind === 'OperationDefinition',\n  )[0] as OperationDefinitionNode;\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        definition =>\n          definition.kind === 'OperationDefinition' && definition.name,\n      )\n      .map((x: OperationDefinitionNode) => x!.name!.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode,\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    definition => definition.kind === 'FragmentDefinition',\n  ) as FragmentDefinitionNode[];\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc) as OperationDefinitionNode;\n\n  invariant(\n    queryDef && queryDef.operation === 'query',\n    'Must contain a query definition.',\n  );\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode,\n): FragmentDefinitionNode {\n  invariant(\n    doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  invariant(\n    doc.definitions.length <= 1,\n    'Fragment must have exactly one definition.',\n  );\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  invariant(\n    fragmentDef.kind === 'FragmentDefinition',\n    'Must be a fragment definition.',\n  );\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode,\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === 'OperationDefinition') {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === 'query' ||\n        operation === 'mutation' ||\n        operation === 'subscription'\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw new InvariantError(\n    'Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.',\n  );\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined,\n): Record<string, any> {\n  const defaultValues = Object.create(null);\n  const defs = definition && definition.variableDefinitions;\n  if (defs && defs.length) {\n    defs.forEach(def => {\n      if (def.defaultValue) {\n        valueToObjectRepresentation(\n          defaultValues,\n          def.variable.name,\n          def.defaultValue as ValueNode,\n        );\n      }\n    });\n  }\n  return defaultValues;\n}\n", "export function filterInPlace<T>(\n  array: T[],\n  test: (elem: T) => boolean,\n  context?: any,\n): T[] {\n  let target = 0;\n  array.forEach(function (elem, i) {\n    if (test.call(this, elem, i, array)) {\n      array[target++] = elem;\n    }\n  }, context);\n  array.length = target;\n  return array;\n}\n", "import { invariant } from '../globals';\n\nimport {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  VariableNode,\n  visit,\n  ASTNode,\n} from 'graphql';\n\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype Kind = any;\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  getMainDefinition,\n} from './getFromAST';\nimport { filterInPlace } from '../common/filterInPlace';\nimport { isField, isInlineFragment } from './storeUtils';\nimport {\n  createFragmentMap,\n  FragmentMap,\n} from './fragments';\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig = RemoveNodeConfig<\n  FragmentDefinitionNode\n>;\nexport type RemoveVariableDefinitionConfig = RemoveNodeConfig<\n  VariableDefinitionNode\n>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: 'Field' as Kind,\n  name: {\n    kind: 'Name' as Kind,\n    value: '__typename',\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragments: FragmentMap,\n): boolean {\n  return op.selectionSet.selections.every(\n    selection =>\n      selection.kind === 'FragmentSpread' &&\n      isEmpty(fragments[selection.name.value], fragments),\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return isEmpty(\n    getOperationDefinition(doc) || getFragmentDefinition(doc),\n    createFragmentMap(getFragmentDefinitions(doc)),\n  )\n    ? null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  return function directiveMatcher(directive: DirectiveNode) {\n    return directives.some(\n      dir =>\n        (dir.name && dir.name === directive.name.value) ||\n        (dir.test && dir.test(directive)),\n    );\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const variablesInUse: Record<string, boolean> = Object.create(null);\n  let variablesToRemove: RemoveArgumentsConfig[] = [];\n\n  const fragmentSpreadsInUse: Record<string, boolean> = Object.create(null);\n  let fragmentSpreadsToRemove: RemoveFragmentSpreadConfig[] = [];\n\n  let modifiedDoc = nullIfDocIsEmpty(\n    visit(doc, {\n      Variable: {\n        enter(node, _key, parent) {\n          // Store each variable that's referenced as part of an argument\n          // (excluding operation definition variables), so we know which\n          // variables are being used. If we later want to remove a variable\n          // we'll first check to see if it's being used, before continuing with\n          // the removal.\n          if (\n            (parent as VariableDefinitionNode).kind !== 'VariableDefinition'\n          ) {\n            variablesInUse[node.name.value] = true;\n          }\n        },\n      },\n\n      Field: {\n        enter(node) {\n          if (directives && node.directives) {\n            // If `remove` is set to true for a directive, and a directive match\n            // is found for a field, remove the field as well.\n            const shouldRemoveField = directives.some(\n              directive => directive.remove,\n            );\n\n            if (\n              shouldRemoveField &&\n              node.directives &&\n              node.directives.some(getDirectiveMatcher(directives))\n            ) {\n              if (node.arguments) {\n                // Store field argument variables so they can be removed\n                // from the operation definition.\n                node.arguments.forEach(arg => {\n                  if (arg.value.kind === 'Variable') {\n                    variablesToRemove.push({\n                      name: (arg.value as VariableNode).name.value,\n                    });\n                  }\n                });\n              }\n\n              if (node.selectionSet) {\n                // Store fragment spread names so they can be removed from the\n                // document.\n                getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(\n                  frag => {\n                    fragmentSpreadsToRemove.push({\n                      name: frag.name.value,\n                    });\n                  },\n                );\n              }\n\n              // Remove the field.\n              return null;\n            }\n          }\n        },\n      },\n\n      FragmentSpread: {\n        enter(node) {\n          // Keep track of referenced fragment spreads. This is used to\n          // determine if top level fragment definitions should be removed.\n          fragmentSpreadsInUse[node.name.value] = true;\n        },\n      },\n\n      Directive: {\n        enter(node) {\n          // If a matching directive is found, remove it.\n          if (getDirectiveMatcher(directives)(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n\n  // If we've removed fields with arguments, make sure the associated\n  // variables are also removed from the rest of the document, as long as they\n  // aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(variablesToRemove, v => !!v.name && !variablesInUse[v.name]).length\n  ) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n\n  // If we've removed selection sets with fragment spreads, make sure the\n  // associated fragment definitions are also removed from the rest of the\n  // document, as long as they aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(fragmentSpreadsToRemove, fs => !!fs.name && !fragmentSpreadsInUse[fs.name])\n      .length\n  ) {\n    modifiedDoc = removeFragmentSpreadFromDocument(\n      fragmentSpreadsToRemove,\n      modifiedDoc,\n    );\n  }\n\n  return modifiedDoc;\n}\n\nexport const addTypenameToDocument = Object.assign(function <\n  TNode extends ASTNode\n>(\n  doc: TNode\n): TNode {\n  return visit(doc, {\n    SelectionSet: {\n      enter(node, _key, parent) {\n        // Don't add __typename to OperationDefinitions.\n        if (\n          parent &&\n          (parent as OperationDefinitionNode).kind === 'OperationDefinition'\n        ) {\n          return;\n        }\n\n        // No changes if no selections.\n        const { selections } = node;\n        if (!selections) {\n          return;\n        }\n\n        // If selections already have a __typename, or are part of an\n        // introspection query, do nothing.\n        const skip = selections.some(selection => {\n          return (\n            isField(selection) &&\n            (selection.name.value === '__typename' ||\n              selection.name.value.lastIndexOf('__', 0) === 0)\n          );\n        });\n        if (skip) {\n          return;\n        }\n\n        // If this SelectionSet is @export-ed as an input variable, it should\n        // not have a __typename field (see issue #4691).\n        const field = parent as FieldNode;\n        if (\n          isField(field) &&\n          field.directives &&\n          field.directives.some(d => d.name.value === 'export')\n        ) {\n          return;\n        }\n\n        // Create and return a new SelectionSet with a __typename Field.\n        return {\n          ...node,\n          selections: [...selections, TYPENAME_FIELD],\n        };\n      },\n    },\n  });\n}, {\n  added(field: FieldNode): boolean {\n    return field === TYPENAME_FIELD;\n  },\n});\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        invariant.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc),\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode | undefined,\n  nestedCheck = true,\n): boolean {\n  return (\n    !!selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some(selection =>\n      hasDirectivesInSelection(directives, selection, nestedCheck),\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === 'Variable' &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument))),\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(\n              varDef =>\n                !config.some(arg => arg.name === varDef.variable.name.value),\n            ) : [],\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(argConfig => argConfig.remove);\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            if (node.arguments) {\n              node.arguments.forEach(arg => {\n                if (argMatcher(arg)) {\n                  argMatchCount += 1;\n                }\n              });\n            }\n\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode,\n  ): null | void {\n    if (config.some(def => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    }),\n  );\n}\n\nfunction getAllFragmentSpreadsFromSelectionSet(\n  selectionSet: SelectionSetNode,\n): FragmentSpreadNode[] {\n  const allFragments: FragmentSpreadNode[] = [];\n\n  selectionSet.selections.forEach(selection => {\n    if (\n      (isField(selection) || isInlineFragment(selection)) &&\n      selection.selectionSet\n    ) {\n      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(\n        frag => allFragments.push(frag),\n      );\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n\n  return allFragments;\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode,\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === 'query') {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: 'query',\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode,\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === 'client',\n        remove: true,\n      },\n    ],\n    document,\n  );\n\n  // After a fragment definition has had its @client related document\n  // sets removed, if the only field it has left is a __typename field,\n  // remove the entire fragment operation to prevent it from being fired\n  // on the server.\n  if (modifiedDoc) {\n    modifiedDoc = visit(modifiedDoc, {\n      FragmentDefinition: {\n        enter(node) {\n          if (node.selectionSet) {\n            const isTypenameOnly = node.selectionSet.selections.every(\n              selection =>\n                isField(selection) && selection.name.value === '__typename',\n            );\n            if (isTypenameOnly) {\n              return null;\n            }\n          }\n        },\n      },\n    });\n  }\n\n  return modifiedDoc;\n}\n", "import { isNonNullObject } from \"./objects\";\n\nconst { hasOwnProperty } = Object.prototype;\n\n// These mergeDeep and mergeDeepArray utilities merge any number of objects\n// together, sharing as much memory as possible with the source objects, while\n// remaining careful to avoid modifying any source objects.\n\n// Logically, the return type of mergeDeep should be the intersection of\n// all the argument types. The binary call signature is by far the most\n// common, but we support 0- through 5-ary as well. After that, the\n// resulting type is just the inferred array element type. Note to nerds:\n// there is a more clever way of doing this that converts the tuple type\n// first to a union type (easy enough: T[number]) and then converts the\n// union to an intersection type using distributive conditional type\n// inference, but that approach has several fatal flaws (boolean becomes\n// true & false, and the inferred type ends up as unknown in many cases),\n// in addition to being nearly impossible to explain/understand.\nexport type TupleToIntersection<T extends any[]> =\n  T extends [infer A] ? A :\n  T extends [infer A, infer B] ? A & B :\n  T extends [infer A, infer B, infer C] ? A & B & C :\n  T extends [infer A, infer B, infer C, infer D] ? A & B & C & D :\n  T extends [infer A, infer B, infer C, infer D, infer E] ? A & B & C & D & E :\n  T extends (infer U)[] ? U : any;\n\nexport function mergeDeep<T extends any[]>(\n  ...sources: T\n): TupleToIntersection<T> {\n  return mergeDeepArray(sources);\n}\n\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray<T>(sources: T[]): T {\n  let target = sources[0] || ({} as T);\n  const count = sources.length;\n  if (count > 1) {\n    const merger = new DeepMerger();\n    for (let i = 1; i < count; ++i) {\n      target = merger.merge(target, sources[i]);\n    }\n  }\n  return target;\n}\n\nexport type ReconcilerFunction<TContextArgs extends any[]> = (\n  this: DeepMerger<TContextArgs>,\n  target: Record<string | number, any>,\n  source: Record<string | number, any>,\n  property: string | number,\n  ...context: TContextArgs\n) => any;\n\nconst defaultReconciler: ReconcilerFunction<any[]> =\n  function (target, source, property) {\n    return this.merge(target[property], source[property]);\n  };\n\nexport class DeepMerger<TContextArgs extends any[]> {\n  constructor(\n    private reconciler: ReconcilerFunction<TContextArgs> = defaultReconciler,\n  ) {}\n\n  public merge(target: any, source: any, ...context: TContextArgs): any {\n    if (isNonNullObject(source) && isNonNullObject(target)) {\n      Object.keys(source).forEach(sourceKey => {\n        if (hasOwnProperty.call(target, sourceKey)) {\n          const targetValue = target[sourceKey];\n          if (source[sourceKey] !== targetValue) {\n            const result = this.reconciler(target, source, sourceKey, ...context);\n            // A well-implemented reconciler may return targetValue to indicate\n            // the merge changed nothing about the structure of the target.\n            if (result !== targetValue) {\n              target = this.shallowCopyForMerge(target);\n              target[sourceKey] = result;\n            }\n          }\n        } else {\n          // If there is no collision, the target can safely share memory with\n          // the source, and the recursion can terminate here.\n          target = this.shallowCopyForMerge(target);\n          target[sourceKey] = source[sourceKey];\n        }\n      });\n\n      return target;\n    }\n\n    // If source (or target) is not an object, let source replace target.\n    return source;\n  }\n\n  public isObject = isNonNullObject;\n\n  private pastCopies = new Set<any>();\n\n  public shallowCopyForMerge<T>(value: T): T {\n    if (isNonNullObject(value)) {\n      if (!this.pastCopies.has(value)) {\n        if (Array.isArray(value)) {\n          value = (value as any).slice(0);\n        } else {\n          value = {\n            __proto__: Object.getPrototypeOf(value),\n            ...value,\n          };\n        }\n        this.pastCopies.add(value);\n      }\n    }\n    return value;\n  }\n}\n", "const { toString } = Object.prototype;\n\n/**\n * Deeply clones a value to create a new instance.\n */\nexport function cloneDeep<T>(value: T): T {\n  return cloneDeepHelper(value);\n}\n\nfunction cloneDeepHelper<T>(val: T, seen?: Map<any, any>): T {\n  switch (toString.call(val)) {\n  case \"[object Array]\": {\n    seen = seen || new Map;\n    if (seen.has(val)) return seen.get(val);\n    const copy: T & any[] = (val as any).slice(0);\n    seen.set(val, copy);\n    copy.forEach(function (child, i) {\n      copy[i] = cloneDeepHelper(child, seen);\n    });\n    return copy;\n  }\n\n  case \"[object Object]\": {\n    seen = seen || new Map;\n    if (seen.has(val)) return seen.get(val);\n    // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n    // possible in all JS environments, so we will assume they exist/work.\n    const copy = Object.create(Object.getPrototypeOf(val));\n    seen.set(val, copy);\n    Object.keys(val).forEach(key => {\n      copy[key] = cloneDeepHelper((val as any)[key], seen);\n    });\n    return copy;\n  }\n\n  default:\n    return val;\n  }\n}\n", "import '../globals'; // For __DEV__\nimport { isNonNullObject } from './objects';\n\nfunction deepFreeze(value: any) {\n  const workSet = new Set([value]);\n  workSet.forEach(obj => {\n    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {\n      Object.getOwnPropertyNames(obj).forEach(name => {\n        if (isNonNullObject(obj[name])) workSet.add(obj[name]);\n      });\n    }\n  });\n  return value;\n}\n\nfunction shallowFreeze<T extends object>(obj: T): T | null {\n  if (__DEV__ && !Object.isFrozen(obj)) {\n    try {\n      Object.freeze(obj);\n    } catch (e) {\n      // Some types like Uint8Array and Node.js's Buffer cannot be frozen, but\n      // they all throw a TypeError when you try, so we re-throw any exceptions\n      // that are not TypeErrors, since that would be unexpected.\n      if (e instanceof TypeError) return null;\n      throw e;\n    }\n  }\n  return obj;\n}\n\nexport function maybeDeepFreeze<T>(obj: T): T {\n  if (__DEV__) {\n    deepFreeze(obj);\n  }\n  return obj;\n}\n", "import { Observer } from \"./Observable\";\n\nexport function iterateObserversSafely<E, A>(\n  observers: Set<Observer<E>>,\n  method: keyof Observer<E>,\n  argument?: A,\n) {\n  // In case observers is modified during iteration, we need to commit to the\n  // original elements, which also provides an opportunity to filter them down\n  // to just the observers with the given method.\n  const observersWithMethod: Observer<E>[] = [];\n  observers.forEach(obs => obs[method] && observersWithMethod.push(obs));\n  observersWithMethod.forEach(obs => (obs as any)[method](argument));\n}\n", "import { Observable, Observer } from \"./Observable\";\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | PromiseLike<R>,\n  catchFn?: (error: any) => R | PromiseLike<R>,\n): Observable<R> {\n  return new Observable<R>(observer => {\n    const { next, error, complete } = observer;\n    let activeCallbackCount = 0;\n    let completed = false;\n    let promiseQueue = {\n      // Normally we would initialize promiseQueue to Promise.resolve(), but\n      // in this case, for backwards compatibility, we need to be careful to\n      // invoke the first callback synchronously.\n      then(callback: () => any) {\n        return new Promise(resolve => resolve(callback()));\n      },\n    } as Promise<void>;\n\n    function makeCallback(\n      examiner: typeof mapFn | typeof catchFn,\n      delegate: typeof next | typeof error,\n    ): (arg: any) => void {\n      if (examiner) {\n        return arg => {\n          ++activeCallbackCount;\n          const both = () => examiner(arg);\n          promiseQueue = promiseQueue.then(both, both).then(\n            result => {\n              --activeCallbackCount;\n              next && next.call(observer, result);\n              if (completed) {\n                handler.complete!();\n              }\n            },\n            error => {\n              --activeCallbackCount;\n              throw error;\n            },\n          ).catch(caught => {\n            error && error.call(observer, caught);\n          });\n        };\n      } else {\n        return arg => delegate && delegate.call(observer, arg);\n      }\n    }\n\n    const handler: Observer<V> = {\n      next: makeCallback(mapFn, next),\n      error: makeCallback(catchFn, error),\n      complete() {\n        completed = true;\n        if (!activeCallbackCount) {\n          complete && complete.call(observer);\n        }\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n", "import { maybe } from \"../globals\";\n\nexport const canUseWeakMap =\n  typeof WeakMap === 'function' &&\n  maybe(() => navigator.product) !== 'ReactNative';\n\nexport const canUseWeakSet = typeof WeakSet === 'function';\n\nexport const canUseSymbol =\n  typeof Symbol === 'function' &&\n  typeof Symbol.for === 'function';\n\nexport const canUseDOM =\n  typeof maybe(() => window.document.createElement) === \"function\";\n\nconst usingJSDOM: boolean =\n  // Following advice found in this comment from @domenic (maintainer of jsdom):\n  // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327\n  //\n  // Since we control the version of Jest and jsdom used when running Apollo\n  // Client tests, and that version is recent enought to include \" jsdom/x.y.z\"\n  // at the end of the user agent string, I believe this case is all we need to\n  // check. Testing for \"Node.js\" was recommended for backwards compatibility\n  // with older version of jsdom, but we don't have that problem.\n  maybe(() => navigator.userAgent.indexOf(\"jsdom\") >= 0) || false;\n\n// Our tests should all continue to pass if we remove this !usingJSDOM\n// condition, thereby allowing useLayoutEffect when using jsdom. Unfortunately,\n// if we allow useLayoutEffect, then useSyncExternalStore generates many\n// warnings about useLayoutEffect doing nothing on the server. While these\n// warnings are harmless, this !usingJSDOM condition seems to be the best way to\n// prevent them (i.e. skipping useLayoutEffect when using jsdom).\nexport const canUseLayoutEffect = canUseDOM && !usingJSDOM;\n", "import { Observable } from \"./Observable\";\nimport { canUseSymbol } from \"../common/canUse\";\n\n// Generic implementations of Observable.prototype methods like map and\n// filter need to know how to create a new Observable from an Observable\n// subclass (like Concast or ObservableQuery). Those methods assume\n// (perhaps unwisely?) that they can call the subtype's constructor with a\n// Subscriber function, even though the subclass constructor might expect\n// different parameters. Defining this static Symbol.species property on\n// the subclass is a hint to generic Observable code to use the default\n// constructor instead of trying to do `new Subclass(observer => ...)`.\nexport function fixObservableSubclass<\n  S extends new (...args: any[]) => Observable<any>,\n>(subclass: S): S {\n  function set(key: symbol | string) {\n    // Object.defineProperty is necessary because the Symbol.species\n    // property is a getter by default in modern JS environments, so we\n    // can't assign to it with a normal assignment expression.\n    Object.defineProperty(subclass, key, { value: Observable });\n  }\n  if (canUseSymbol && Symbol.species) {\n    set(Symbol.species);\n  }\n  // The \"@@species\" string is used as a fake Symbol.species value in some\n  // polyfill systems (including the SymbolSpecies variable used by\n  // zen-observable), so we should set it as well, to be safe.\n  set(\"@@species\");\n  return subclass;\n}\n", "import { Observable, Observer, ObservableSubscription, Subscriber } from \"./Observable\";\nimport { iterateObserversSafely } from \"./iteration\";\nimport { fixObservableSubclass } from \"./subclassing\";\n\ntype MaybeAsync<T> = T | PromiseLike<T>;\n\nfunction isPromiseLike<T>(value: MaybeAsync<T>): value is PromiseLike<T> {\n  return value && typeof (value as any).then === \"function\";\n}\n\n// Any individual Source<T> can be an Observable<T> or a promise for one.\ntype Source<T> = MaybeAsync<Observable<T>>;\n\nexport type ConcastSourcesIterable<T> = Iterable<Source<T>>;\nexport type ConcastSourcesArray<T> = Array<Source<T>>;\n\n// A Concast<T> observable concatenates the given sources into a single\n// non-overlapping sequence of Ts, automatically unwrapping any promises,\n// and broadcasts the T elements of that sequence to any number of\n// subscribers, all without creating a bunch of intermediary Observable\n// wrapper objects.\n//\n// Even though any number of observers can subscribe to the Concast, each\n// source observable is guaranteed to receive at most one subscribe call,\n// and the results are multicast to all observers.\n//\n// In addition to broadcasting every next/error message to this.observers,\n// the Concast stores the most recent message using this.latest, so any\n// new observers can immediately receive the latest message, even if it\n// was originally delivered in the past. This behavior means we can assume\n// every active observer in this.observers has received the same most\n// recent message.\n//\n// With the exception of this.latest replay, a Concast is a \"hot\"\n// observable in the sense that it does not replay past results from the\n// beginning of time for each new observer.\n//\n// Could we have used some existing RxJS class instead? Concast<T> is\n// similar to a BehaviorSubject<T>, because it is multicast and redelivers\n// the latest next/error message to new subscribers. Unlike Subject<T>,\n// Concast<T> does not expose an Observer<T> interface (this.handlers is\n// intentionally private), since Concast<T> gets its inputs from the\n// concatenated sources. If we ever switch to RxJS, there may be some\n// value in reusing their code, but for now we use zen-observable, which\n// does not contain any Subject implementations.\nexport class Concast<T> extends Observable<T> {\n  // Active observers receiving broadcast messages. Thanks to this.latest,\n  // we can assume all observers in this Set have received the same most\n  // recent message, though possibly at different times in the past.\n  private observers = new Set<Observer<T>>();\n\n  // This property starts off undefined to indicate the initial\n  // subscription has not yet begun, then points to each source\n  // subscription in turn, and finally becomes null after the sources have\n  // been exhausted. After that, it stays null.\n  private sub?: ObservableSubscription | null;\n\n  // Not only can the individual elements of the iterable be promises, but\n  // also the iterable itself can be wrapped in a promise.\n  constructor(sources: MaybeAsync<ConcastSourcesIterable<T>> | Subscriber<T>) {\n    super(observer => {\n      this.addObserver(observer);\n      return () => this.removeObserver(observer);\n    });\n\n    // Suppress rejection warnings for this.promise, since it's perfectly\n    // acceptable to pay no attention to this.promise if you're consuming\n    // the results through the normal observable API.\n    this.promise.catch(_ => {});\n\n    // If someone accidentally tries to create a Concast using a subscriber\n    // function, recover by creating an Observable from that subscriber and\n    // using it as the source.\n    if (typeof sources === \"function\") {\n      sources = [new Observable(sources)];\n    }\n\n    if (isPromiseLike(sources)) {\n      sources.then(\n        iterable => this.start(iterable),\n        this.handlers.error,\n      );\n    } else {\n      this.start(sources);\n    }\n  }\n\n  // A consumable array of source observables, incrementally consumed\n  // each time this.handlers.complete is called.\n  private sources: Source<T>[];\n\n  private start(sources: ConcastSourcesIterable<T>) {\n    if (this.sub !== void 0) return;\n\n    // In practice, sources is most often simply an Array of observables.\n    // TODO Consider using sources[Symbol.iterator]() to take advantage\n    // of the laziness of non-Array iterables.\n    this.sources = Array.from(sources);\n\n    // Calling this.handlers.complete() kicks off consumption of the first\n    // source observable. It's tempting to do this step lazily in\n    // addObserver, but this.promise can be accessed without calling\n    // addObserver, so consumption needs to begin eagerly.\n    this.handlers.complete();\n  }\n\n  private deliverLastMessage(observer: Observer<T>) {\n    if (this.latest) {\n      const nextOrError = this.latest[0];\n      const method = observer[nextOrError];\n      if (method) {\n        method.call(observer, this.latest[1]);\n      }\n      // If the subscription is already closed, and the last message was\n      // a 'next' message, simulate delivery of the final 'complete'\n      // message again.\n      if (this.sub === null &&\n          nextOrError === \"next\" &&\n          observer.complete) {\n        observer.complete();\n      }\n    }\n  }\n\n  // Note: cleanup observers do not count towards this total.\n  private addCount = 0;\n\n  public addObserver(observer: Observer<T>) {\n    if (!this.observers.has(observer)) {\n      // Immediately deliver the most recent message, so we can always\n      // be sure all observers have the latest information.\n      this.deliverLastMessage(observer);\n      this.observers.add(observer);\n      ++this.addCount;\n    }\n  }\n\n  public removeObserver(\n    observer: Observer<T>,\n    quietly?: boolean,\n  ) {\n    if (this.observers.delete(observer) &&\n        --this.addCount < 1 &&\n        !quietly) {\n      // In case there are still any cleanup observers in this.observers, and no\n      // error or completion has been broadcast yet, make sure those observers\n      // have a chance to run and then remove themselves from this.observers.\n      this.handlers.complete();\n    }\n  }\n\n  // Any Concast object can be trivially converted to a Promise, without\n  // having to create a new wrapper Observable. This promise provides an\n  // easy way to observe the final state of the Concast.\n  private resolve: (result?: T | PromiseLike<T>) => void;\n  private reject: (reason: any) => void;\n  public readonly promise = new Promise<T>((resolve, reject) => {\n    this.resolve = resolve;\n    this.reject = reject;\n  });\n\n  // Name and argument of the most recently invoked observer method, used\n  // to deliver latest results immediately to new observers.\n  private latest?: [\"next\" | \"error\", any];\n\n  // Bound handler functions that can be reused for every internal\n  // subscription.\n  private handlers = {\n    next: (result: T) => {\n      if (this.sub !== null) {\n        this.latest = [\"next\", result];\n        iterateObserversSafely(this.observers, \"next\", result);\n      }\n    },\n\n    error: (error: any) => {\n      const { sub } = this;\n      if (sub !== null) {\n        // Delay unsubscribing from the underlying subscription slightly,\n        // so that immediately subscribing another observer can keep the\n        // subscription active.\n        if (sub) setTimeout(() => sub.unsubscribe());\n        this.sub = null;\n        this.latest = [\"error\", error];\n        this.reject(error);\n        iterateObserversSafely(this.observers, \"error\", error);\n      }\n    },\n\n    complete: () => {\n      const { sub } = this;\n      if (sub !== null) {\n        const value = this.sources.shift();\n        if (!value) {\n          if (sub) setTimeout(() => sub.unsubscribe());\n          this.sub = null;\n          if (this.latest &&\n              this.latest[0] === \"next\") {\n            this.resolve(this.latest[1]);\n          } else {\n            this.resolve();\n          }\n          // We do not store this.latest = [\"complete\"], because doing so\n          // discards useful information about the previous next (or\n          // error) message. Instead, if new observers subscribe after\n          // this Concast has completed, they will receive the final\n          // 'next' message (unless there was an error) immediately\n          // followed by a 'complete' message (see addObserver).\n          iterateObserversSafely(this.observers, \"complete\");\n        } else if (isPromiseLike(value)) {\n          value.then(obs => this.sub = obs.subscribe(this.handlers));\n        } else {\n          this.sub = value.subscribe(this.handlers);\n        }\n      }\n    },\n  };\n\n  public cleanup(callback: () => any) {\n    let called = false;\n    const once = () => {\n      if (!called) {\n        called = true;\n        // Removing a cleanup observer should not unsubscribe from the\n        // underlying Observable, so the only removeObserver behavior we\n        // need here is to delete observer from this.observers.\n        this.observers.delete(observer);\n        callback();\n      }\n    }\n    const observer = {\n      next: once,\n      error: once,\n      complete: once,\n    };\n    const count = this.addCount;\n    this.addObserver(observer);\n    // Normally addObserver increments this.addCount, but we can \"hide\"\n    // cleanup observers by restoring this.addCount to its previous value\n    // after adding any cleanup observer.\n    this.addCount = count;\n  }\n\n  // A public way to abort observation and broadcast.\n  public cancel = (reason: any) => {\n    this.reject(reason);\n    this.sources = [];\n    this.handlers.complete();\n  }\n}\n\n// Necessary because the Concast constructor has a different signature\n// than the Observable constructor.\nfixObservableSubclass(Concast);\n", "export function isNonEmptyArray<T>(value?: ArrayLike<T>): value is Array<T> {\n  return Array.isArray(value) && value.length > 0;\n}\n", "import { ExecutionResult } from 'graphql';\n\nexport function graphQLResultHasError(result: ExecutionResult<unknown>): boolean {\n  return (result.errors && result.errors.length > 0) || false;\n}\n", "const prefixCounts = new Map<string, number>();\n\n// These IDs won't be globally unique, but they will be unique within this\n// process, thanks to the counter, and unguessable thanks to the random suffix.\nexport function makeUniqueId(prefix: string) {\n  const count = prefixCounts.get(prefix) || 1;\n  prefixCounts.set(prefix, count + 1);\n  return `${prefix}:${count}:${Math.random().toString(36).slice(2)}`;\n}\n", "import { makeUniqueId } from \"./makeUniqueId\";\n\nexport function stringifyForDisplay(value: any): string {\n  const undefId = makeUniqueId(\"stringifyForDisplay\");\n  return JSON.stringify(value, (key, value) => {\n    return value === void 0 ? undefId : value;\n  }).split(JSON.stringify(undefId)).join(\"<undefined>\");\n}\n", "import { Observable } from '../../utilities';\n\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>(observer => {\n    observer.error(errorValue);\n  });\n}\n", "import { invariant } from '../../utilities/globals';\nimport { Observable } from '../../utilities';\n\nexport function toPromise<R>(observable: Observable<R>): Promise<R> {\n  let completed = false;\n  return new Promise<R>((resolve, reject) => {\n    observable.subscribe({\n      next: data => {\n        if (completed) {\n          invariant.warn(\n            `Promise Wrapper does not support multiple results from Observable`,\n          );\n        } else {\n          completed = true;\n          resolve(data);\n        }\n      },\n      error: reject,\n    });\n  });\n}\n", "import { Observable } from '../../utilities';\n\nexport function fromPromise<T>(promise: Promise<T>): Observable<T> {\n  return new Observable<T>(observer => {\n    promise\n      .then((value: T) => {\n        observer.next(value);\n        observer.complete();\n      })\n      .catch(observer.error.bind(observer));\n  });\n}\n", "export type ServerError = Error & {\n  response: Response;\n  result: Record<string, any>;\n  statusCode: number;\n};\n\nexport const throwServerError = (\n  response: Response,\n  result: any,\n  message: string\n) => {\n  const error = new Error(message) as ServerError;\n  error.name = 'ServerError';\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n  throw error;\n};\n", "import { InvariantError } from '../../utilities/globals'\nimport { GraphQLRequest } from '../core';\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    'query',\n    'operationName',\n    'variables',\n    'extensions',\n    'context',\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw new InvariantError(`illegal argument: ${key}`);\n    }\n  }\n\n  return operation;\n}\n", "import { GraphQLRequest, Operation } from '../core';\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest,\n): Operation {\n  let context = { ...starting };\n  const setContext = (next: any) => {\n    if (typeof next === 'function') {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext = () => ({ ...context });\n\n  Object.defineProperty(operation, 'setContext', {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, 'getContext', {\n    enumerable: false,\n    value: getContext,\n  });\n\n  return operation as Operation;\n}\n", "import { GraphQLRequest, Operation } from '../core';\nimport { getOperationName } from '../../utilities';\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // Best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== 'string'\n        ? getOperationName(transformedOperation.query) || undefined\n        : '';\n  }\n\n  return transformedOperation as Operation;\n}\n", "import { InvariantError, invariant } from '../../utilities/globals';\n\nimport { Observable, Observer } from '../../utilities';\nimport {\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n  GraphQLRequest\n} from './types';\nimport {\n  validateOperation,\n  createOperation,\n  transformOperation,\n} from '../utils';\n\nfunction passthrough(op: Operation, forward: NextLink) {\n  return (forward ? forward(op) : Observable.of()) as Observable<FetchResult>;\n}\n\nfunction toLink(handler: RequestHandler | ApolloLink) {\n  return typeof handler === 'function' ? new ApolloLink(handler) : handler;\n}\n\nfunction isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nclass LinkError extends Error {\n  public link?: ApolloLink;\n  constructor(message?: string, link?: ApolloLink) {\n    super(message);\n    this.link = link;\n  }\n}\n\nexport class ApolloLink {\n  public static empty(): ApolloLink {\n    return new ApolloLink(() => Observable.of());\n  }\n\n  public static from(links: (ApolloLink | RequestHandler)[]): ApolloLink {\n    if (links.length === 0) return ApolloLink.empty();\n    return links.map(toLink).reduce((x, y) => x.concat(y)) as ApolloLink;\n  }\n\n  public static split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler,\n  ): ApolloLink {\n    const leftLink = toLink(left);\n    const rightLink = toLink(right || new ApolloLink(passthrough));\n\n    if (isTerminating(leftLink) && isTerminating(rightLink)) {\n      return new ApolloLink(operation => {\n        return test(operation)\n          ? leftLink.request(operation) || Observable.of()\n          : rightLink.request(operation) || Observable.of();\n      });\n    } else {\n      return new ApolloLink((operation, forward) => {\n        return test(operation)\n          ? leftLink.request(operation, forward) || Observable.of()\n          : rightLink.request(operation, forward) || Observable.of();\n      });\n    }\n  }\n\n  public static execute(\n    link: ApolloLink,\n    operation: GraphQLRequest,\n  ): Observable<FetchResult> {\n    return (\n      link.request(\n        createOperation(\n          operation.context,\n          transformOperation(validateOperation(operation)),\n        ),\n      ) || Observable.of()\n    );\n  }\n\n  public static concat(\n    first: ApolloLink | RequestHandler,\n    second: ApolloLink | RequestHandler,\n  ) {\n    const firstLink = toLink(first);\n    if (isTerminating(firstLink)) {\n      invariant.warn(\n        new LinkError(\n          `You are calling concat on a terminating link, which will have no effect`,\n          firstLink,\n        ),\n      );\n      return firstLink;\n    }\n    const nextLink = toLink(second);\n\n    if (isTerminating(nextLink)) {\n      return new ApolloLink(\n        operation =>\n          firstLink.request(\n            operation,\n            op => nextLink.request(op) || Observable.of(),\n          ) || Observable.of(),\n      );\n    } else {\n      return new ApolloLink((operation, forward) => {\n        return (\n          firstLink.request(operation, op => {\n            return nextLink.request(op, forward) || Observable.of();\n          }) || Observable.of()\n        );\n      });\n    }\n  }\n\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler,\n  ): ApolloLink {\n    return this.concat(\n      ApolloLink.split(test, left, right || new ApolloLink(passthrough))\n    );\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return ApolloLink.concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    throw new InvariantError('request is not implemented');\n  }\n\n  protected onError(\n    error: any,\n    observer?: Observer<FetchResult>,\n  ): false | void {\n    if (observer && observer.error) {\n      observer.error(error);\n      // Returning false indicates that observer.error does not need to be\n      // called again, since it was already called (on the previous line).\n      // Calling observer.error again would not cause any real problems,\n      // since only the first call matters, but custom onError functions\n      // might have other reasons for wanting to prevent the default\n      // behavior by returning false.\n      return false;\n    }\n    // Throw errors will be passed to observer.error.\n    throw error;\n  }\n\n  public setOnError(fn: ApolloLink[\"onError\"]): this {\n    this.onError = fn;\n    return this;\n  }\n}\n", "import { ApolloLink } from './ApolloLink';\n\nexport const empty = ApolloLink.empty;\n", "import { ApolloLink } from './ApolloLink';\n\nexport const from = ApolloLink.from;\n", "import { ApolloLink } from './ApolloLink';\n\nexport const split = ApolloLink.split;\n", "import { ApolloLink } from './ApolloLink';\n\nexport const concat = ApolloLink.concat;\n", "import { ApolloLink } from './ApolloLink';\n\nexport const execute = ApolloLink.execute;\n"],
  "mappings": "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",
  "names": ["InvariantError", "invariant", "_a", "_a", "maybe", "_a", "result", "Subscription", "SubscriptionObserver", "Observable", "concat", "value", "from", "root", "result", "Symbol", "result", "_a", "root", "result", "_a", "DeepMerger", "result", "result", "error", "Concast", "result", "result", "value", "result", "_a", "LinkError", "ApolloLink"]
}

{
  "version": 3,
  "sources": ["../../filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js", "dep:filepond-plugin-file-validate-type"],
  "sourcesContent": ["/*!\n * FilePondPluginFileValidateType 1.2.8\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\nconst plugin = ({ addFilter, utils }) => {\n  // get quick reference to Type utils\n  const {\n    Type,\n    isString,\n    replaceInString,\n    guesstimateMimeType,\n    getExtensionFromFilename,\n    getFilenameFromURL\n  } = utils;\n\n  const mimeTypeMatchesWildCard = (mimeType, wildcard) => {\n    const mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image\n    const wildcardGroup = wildcard.slice(0, -2); // image/* -> image\n    return mimeTypeGroup === wildcardGroup;\n  };\n\n  const isValidMimeType = (acceptedTypes, userInputType) =>\n    acceptedTypes.some(acceptedType => {\n      // accepted is wildcard mime type\n      if (/\\*$/.test(acceptedType)) {\n        return mimeTypeMatchesWildCard(userInputType, acceptedType);\n      }\n\n      // is normal mime type\n      return acceptedType === userInputType;\n    });\n\n  const getItemType = item => {\n    // if the item is a url we guess the mime type by the extension\n    let type = '';\n    if (isString(item)) {\n      const filename = getFilenameFromURL(item);\n      const extension = getExtensionFromFilename(filename);\n      if (extension) {\n        type = guesstimateMimeType(extension);\n      }\n    } else {\n      type = item.type;\n    }\n\n    return type;\n  };\n\n  const validateFile = (item, acceptedFileTypes, typeDetector) => {\n    // no types defined, everything is allowed \\o/\n    if (acceptedFileTypes.length === 0) {\n      return true;\n    }\n\n    // gets the item type\n    const type = getItemType(item);\n\n    // no type detector, test now\n    if (!typeDetector) {\n      return isValidMimeType(acceptedFileTypes, type);\n    }\n\n    // use type detector\n    return new Promise((resolve, reject) => {\n      typeDetector(item, type)\n        .then(detectedType => {\n          if (isValidMimeType(acceptedFileTypes, detectedType)) {\n            resolve();\n          } else {\n            reject();\n          }\n        })\n        .catch(reject);\n    });\n  };\n\n  const applyMimeTypeMap = map => acceptedFileType =>\n    map[acceptedFileType] === null\n      ? false\n      : map[acceptedFileType] || acceptedFileType;\n\n  // setup attribute mapping for accept\n  addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', map =>\n    Object.assign(map, {\n      accept: 'acceptedFileTypes'\n    })\n  );\n\n  // filtering if an item is allowed in hopper\n  addFilter('ALLOW_HOPPER_ITEM', (file, { query }) => {\n    // if we are not doing file type validation exit\n    if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n      return true;\n    }\n\n    // we validate the file against the accepted file types\n    return validateFile(file, query('GET_ACCEPTED_FILE_TYPES'));\n  });\n\n  // called for each file that is loaded\n  // right before it is set to the item state\n  // should return a promise\n  addFilter(\n    'LOAD_FILE',\n    (file, { query }) =>\n      new Promise((resolve, reject) => {\n        if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n          resolve(file);\n          return;\n        }\n\n        const acceptedFileTypes = query('GET_ACCEPTED_FILE_TYPES');\n\n        // custom type detector method\n        const typeDetector = query('GET_FILE_VALIDATE_TYPE_DETECT_TYPE');\n\n        // if invalid, exit here\n        const validationResult = validateFile(\n          file,\n          acceptedFileTypes,\n          typeDetector\n        );\n\n        const handleRejection = () => {\n          const acceptedFileTypesMapped = acceptedFileTypes\n            .map(\n              applyMimeTypeMap(\n                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP')\n              )\n            )\n            .filter(label => label !== false);\n\n          const acceptedFileTypesMapped_unique = acceptedFileTypesMapped.filter(\n            function(item, index) {\n              return acceptedFileTypesMapped.indexOf(item) === index;\n            }\n          );\n\n          reject({\n            status: {\n              main: query('GET_LABEL_FILE_TYPE_NOT_ALLOWED'),\n              sub: replaceInString(\n                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES'),\n                {\n                  allTypes: acceptedFileTypesMapped_unique.join(', '),\n                  allButLastType: acceptedFileTypesMapped_unique\n                    .slice(0, -1)\n                    .join(', '),\n                  lastType:\n                    acceptedFileTypesMapped_unique[\n                      acceptedFileTypesMapped.length - 1\n                    ]\n                }\n              )\n            }\n          });\n        };\n\n        // has returned new filename immidiately\n        if (typeof validationResult === 'boolean') {\n          if (!validationResult) {\n            return handleRejection();\n          }\n          return resolve(file);\n        }\n\n        // is promise\n        validationResult\n          .then(() => {\n            resolve(file);\n          })\n          .catch(handleRejection);\n      })\n  );\n\n  // expose plugin\n  return {\n    // default options\n    options: {\n      // Enable or disable file type validation\n      allowFileTypeValidation: [true, Type.BOOLEAN],\n\n      // What file types to accept\n      acceptedFileTypes: [[], Type.ARRAY],\n      // - must be comma separated\n      // - mime types: image/png, image/jpeg, image/gif\n      // - extensions: .png, .jpg, .jpeg ( not enabled yet )\n      // - wildcards: image/*\n\n      // label to show when a type is not allowed\n      labelFileTypeNotAllowed: ['File is of invalid type', Type.STRING],\n\n      // nicer label\n      fileValidateTypeLabelExpectedTypes: [\n        'Expects {allButLastType} or {lastType}',\n        Type.STRING\n      ],\n\n      // map mime types to extensions\n      fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],\n\n      // Custom function to detect type of file\n      fileValidateTypeDetectType: [null, Type.FUNCTION]\n    }\n  };\n};\n\n// fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\nconst isBrowser =\n  typeof window !== 'undefined' && typeof window.document !== 'undefined';\nif (isBrowser) {\n  document.dispatchEvent(\n    new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n  );\n}\n\nexport default plugin;\n", "import d from \"./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js\";export default d;"],
  "mappings": "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",
  "names": []
}
